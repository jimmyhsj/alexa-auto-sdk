From fad6bcfc499c34d7283f97f7dc23328db2f70ad3 Mon Sep 17 00:00:00 2001
From: Muni Sakkuru <muni.sakkuru@gmail.com>
Date: Wed, 4 May 2022 17:38:30 -0700
Subject: [PATCH] Alexa Auto SDK Changes for v1.25.0 AVS SDK

For internal reference: c45a534d
---
 .../AVS/AVSDiscoveryEndpointAttributes.h      |   4 +
 .../AVSCommon/AVS/DialogUXStateAggregator.h   |   5 +
 .../include/AVSCommon/AVS/EndpointResources.h | 188 +++++
 AVSCommon/AVS/include/AVSCommon/AVS/Locale.h  |  36 +
 AVSCommon/AVS/src/DialogUXStateAggregator.cpp |  28 +-
 AVSCommon/AVS/src/EndpointResources.cpp       | 221 ++++++
 .../AVS/test/DialogUXStateAggregatorTest.cpp  |  29 +-
 AVSCommon/CMakeLists.txt                      |   4 +
 .../Endpoints/EndpointBuilderInterface.h      |  20 +-
 .../LocaleAssetsManagerInterface.h            |   6 +-
 .../Messaging/MessagingObserverInterface.h    | 129 ++++
 .../LibcurlUtils/CurlEasyHandleWrapper.h      |  42 +-
 .../AVSCommon/Utils/LibcurlUtils/HttpDelete.h |  83 +++
 .../Utils/LibcurlUtils/HttpDeleteInterface.h  |  56 ++
 .../AVSCommon/Utils/LibcurlUtils/HttpGet.h    |  83 +++
 .../Utils/LibcurlUtils/HttpGetInterface.h     |   7 +-
 .../Utils/LibcurlUtils/LibcurlUtils.h         |   5 +-
 .../AVSCommon/Utils/Logger/ThreadMoniker.h    |   9 +-
 .../Utils/MediaPlayer/MediaDescription.h      |  64 +-
 .../LibcurlUtils/CurlEasyHandleWrapper.cpp    |  90 ++-
 .../Utils/src/LibcurlUtils/HttpDelete.cpp     | 129 ++++
 AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp  | 129 ++++
 .../Utils/src/LibcurlUtils/LibcurlUtils.cpp   |  18 +-
 AVSCommon/Utils/src/Logger/Logger.cpp         |   2 +-
 AVSCommon/Utils/src/Logger/ThreadMoniker.cpp  |   5 +-
 .../CapabilitiesDelegate.h                    |   3 +
 .../DiscoveryEventSender.h                    |  13 +-
 .../src/CapabilitiesDelegate.cpp              |   6 +-
 .../src/DiscoveryEventSender.cpp              |  22 +-
 .../src/Utils/DiscoveryUtils.cpp              |  31 +-
 CapabilityAgents/CMakeLists.txt               |   1 +
 .../InteractionModelFactory.h                 |  57 ++
 .../InteractionModelCapabilityAgent.h         |  14 +
 .../acsdkInteractionModel/src/CMakeLists.txt  |   1 +
 .../src/InteractionModelCapabilityAgent.cpp   |  36 +-
 .../src/InteractionModelFactory.cpp           |  47 ++
 CapabilityAgents/Messaging/CMakeLists.txt     |   5 +
 .../Messaging/MessagingCapabilityAgent.h      | 513 +++++++++++++
 CapabilityAgents/Messaging/src/CMakeLists.txt |  13 +
 .../src/MessagingCapabilityAgent.cpp          | 697 ++++++++++++++++++
 .../Messaging/test/CMakeLists.txt             |   8 +
 .../TemplateRuntime/src/TemplateRuntime.cpp   |   2 +-
 CertifiedSender/src/CertifiedSender.cpp       |  12 +-
 .../include/ContextManager/ContextManager.h   |   3 +
 ContextManager/src/ContextManager.cpp         |  63 +-
 .../Endpoints/DefaultEndpointBuilder.h        |   1 +
 .../Endpoints/EndpointAttributeValidation.h   |   8 +
 Endpoints/include/Endpoints/EndpointBuilder.h |   5 +
 Endpoints/src/DefaultEndpointBuilder.cpp      |   6 +
 Endpoints/src/EndpointAttributeValidation.cpp |   4 +
 Endpoints/src/EndpointBuilder.cpp             |  22 +-
 .../include/Metrics/MediaUplCalculator.h      |   4 +-
 .../include/Metrics/TtsUplCalculator.h        |   4 +-
 .../include/Metrics/UplMetricSink.h           |   4 +-
 .../UplCalculator/src/MediaUplCalculator.cpp  |  10 +-
 .../UplCalculator/src/TtsUplCalculator.cpp    |  10 +-
 Metrics/UplCalculator/src/UplMetricSink.cpp   |  18 +-
 PlaylistParser/src/PlaylistUtils.cpp          |   2 -
 .../include/Settings/DeviceSettingsManager.h  |  14 +-
 .../Settings/Types/GeolocationEnablement.h    | 146 ++++
 .../OpusEncoderContext/src/CMakeLists.txt     |  11 +-
 .../acsdkAlerts/AlertsCapabilityAgent.h       |  41 ++
 .../acsdkAlerts/src/AlertsCapabilityAgent.cpp |  54 ++
 .../AlertObserverInterface.h                  |  23 +
 .../include/acsdkAudioPlayer/AudioPlayer.h    |   3 +
 .../acsdkAudioPlayer/src/AudioPlayer.cpp      |  83 ++-
 .../acsdkDeviceSetup/DeviceSetupFactory.h     |  49 ++
 .../acsdkDeviceSetup/src/CMakeLists.txt       |   1 +
 .../src/DeviceSetupFactory.cpp                |  38 +
 .../src/DNDSettingProtocol.cpp                |   8 +-
 .../NotificationsCapabilityAgent.h            |  23 +
 .../src/NotificationsCapabilityAgent.cpp      |  49 ++
 cmakeBuild/BuildDefaults.cmake                |   5 +
 cmakeBuild/cmake/BuildOptions.cmake           |  30 +-
 cmakeBuild/cmake/Crypto.cmake                 |   7 +-
 cmakeBuild/cmake/Sqlite.cmake                 |   7 +-
 .../RegistrationManagerFactory.h              |  57 ++
 .../src/CMakeLists.txt                        |   1 +
 .../src/RegistrationManagerFactory.cpp        |  51 ++
 79 files changed, 3521 insertions(+), 217 deletions(-)
 create mode 100644 AVSCommon/AVS/include/AVSCommon/AVS/EndpointResources.h
 create mode 100644 AVSCommon/AVS/include/AVSCommon/AVS/Locale.h
 create mode 100644 AVSCommon/AVS/src/EndpointResources.cpp
 create mode 100644 AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Messaging/MessagingObserverInterface.h
 create mode 100644 AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDelete.h
 create mode 100644 AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDeleteInterface.h
 create mode 100644 AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGet.h
 create mode 100644 AVSCommon/Utils/src/LibcurlUtils/HttpDelete.cpp
 create mode 100644 AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp
 create mode 100644 CapabilityAgents/InteractionModel/acsdkInteractionModel/include/acsdkInteractionModel/InteractionModelFactory.h
 create mode 100644 CapabilityAgents/InteractionModel/acsdkInteractionModel/src/InteractionModelFactory.cpp
 create mode 100644 CapabilityAgents/Messaging/CMakeLists.txt
 create mode 100644 CapabilityAgents/Messaging/include/Messaging/MessagingCapabilityAgent.h
 create mode 100644 CapabilityAgents/Messaging/src/CMakeLists.txt
 create mode 100644 CapabilityAgents/Messaging/src/MessagingCapabilityAgent.cpp
 create mode 100644 CapabilityAgents/Messaging/test/CMakeLists.txt
 create mode 100644 Settings/include/Settings/Types/GeolocationEnablement.h
 create mode 100644 capabilities/DeviceSetup/acsdkDeviceSetup/include/acsdkDeviceSetup/DeviceSetupFactory.h
 create mode 100644 capabilities/DeviceSetup/acsdkDeviceSetup/src/DeviceSetupFactory.cpp
 create mode 100644 core/acsdkRegistrationManager/include/RegistrationManager/RegistrationManagerFactory.h
 create mode 100644 core/acsdkRegistrationManager/src/RegistrationManagerFactory.cpp

diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/AVSDiscoveryEndpointAttributes.h b/AVSCommon/AVS/include/AVSCommon/AVS/AVSDiscoveryEndpointAttributes.h
index a15c9454..d0c5c681 100644
--- a/AVSCommon/AVS/include/AVSCommon/AVS/AVSDiscoveryEndpointAttributes.h
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/AVSDiscoveryEndpointAttributes.h
@@ -20,6 +20,7 @@
 #include <string>
 #include <vector>
 
+#include <AVSCommon/AVS/EndpointResources.h>
 #include <AVSCommon/SDKInterfaces/Endpoints/EndpointIdentifier.h>
 #include <AVSCommon/Utils/Optional.h>
 
@@ -123,6 +124,9 @@ struct AVSDiscoveryEndpointAttributes {
     /// A non-empty string identifying the endpoint manufacturer name.
     std::string manufacturerName;
 
+    /// An EndpointResources object containing friendly names, manufacturer name and description.
+    EndpointResources endpointResources;
+
     /// The display categories the device belongs to. This field should contain at least one category. See categories
     /// in this document: https://developer.amazon.com/docs/alexa/device-apis/alexa-discovery.html#display-categories
     /// @note: This value should only include ALEXA_VOICE_ENABLED for the default endpoint.
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/DialogUXStateAggregator.h b/AVSCommon/AVS/include/AVSCommon/AVS/DialogUXStateAggregator.h
index 10765972..620609ad 100644
--- a/AVSCommon/AVS/include/AVSCommon/AVS/DialogUXStateAggregator.h
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/DialogUXStateAggregator.h
@@ -142,6 +142,8 @@ public:
     void onRequestProcessingCompleted() override;
     /// @}
 
+    void setContinueWithInvalidTransition(bool continueWithInvalidTransition);
+
 private:
     /**
      * Notifies all observers of the current state. This should only be used within the internal executor.
@@ -249,6 +251,9 @@ private:
     /// Contains the current state of the @c AudioInputProcessor as reported by @c AudioInputProcessorObserverInterface
     std::atomic<alexaClientSDK::avsCommon::sdkInterfaces::AudioInputProcessorObserverInterface::State>
         m_audioInputProcessorState;
+
+    /// 
+    std::atomic<bool> m_continueWithInvalidTransition;
 };
 
 }  // namespace avs
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/EndpointResources.h b/AVSCommon/AVS/include/AVSCommon/AVS/EndpointResources.h
new file mode 100644
index 00000000..a81ec512
--- /dev/null
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/EndpointResources.h
@@ -0,0 +1,188 @@
+/*
+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_ENDPOINTRESOURCES_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_ENDPOINTRESOURCES_H_
+
+#include <string>
+#include <vector>
+
+#include <AVSCommon/AVS/Locale.h>
+#include <AVSCommon/Utils/Optional.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace avs {
+
+class EndpointResources {
+public:
+    /**
+     * The constructor.
+     */
+    EndpointResources();
+
+    /**
+     * Function to add friendly name using asset id.
+     * 
+     * @param assetId The asset id of the friendly name.
+     * @return This instance to facilitate setting more information to this EndpointResources.
+     */
+    EndpointResources& addFriendlyNameWithAssetId(const std::string& assetId);
+
+    /**
+     * Function to add friendly name using text value and its locale.
+     *
+     * @note When using this method it is recommended to provide the friendly names
+     * in all the Alexa supported languages. See the class-level link to find the currently
+     * supported languages.
+     *
+     * @note Providing an unsupported locale will result in Discovery failure.
+     *
+     * @param text The text of the friendly name. This value can contain up to 128 valid characters.
+     * @param locale The non-empty locale of the friendly name. 
+     * @return This instance to facilitate setting more information to this EndpointResources.
+     */
+    EndpointResources& addFriendlyNameWithText(
+            const std::string& text,
+            const avsCommon::avs::Locale& locale);
+
+    /**
+     * Function to add manufacturer name using asset id.
+     *
+     * @param assetId The asset id of the manufacturer name using @c string.
+     * @return This instance to facilitate setting more information to this EndpointResources.
+     */
+    EndpointResources& addManufacturerNameWithAssetId(const std::string& assetId);
+
+    /**
+     * Function to add manufacturer name using text value and its locale.
+     *
+     * @note When using this method it is recommended to provide the manufacturer name
+     * in all the Alexa supported languages. See the class-level link to find the currently
+     * supported languages.
+     *
+     * @note Providing an unsupported locale will result in Discovery failure.
+     *
+     * @param text The text of the manufacturer name. This value can contain up to 128 valid characters.
+     * @param locale The non-empty locale of the manufacturer name.
+     * @return This instance to facilitate setting more information to this EndpointResources.
+     */
+    EndpointResources& addManufacturerNameWithText(
+            const std::string& text,
+            const avsCommon::avs::Locale& locale);
+
+    /**
+     * Function to add description using asset id.
+     *
+     * @param assetId The asset id of the description using @c string.
+     * @return This instance to facilitate setting more information to this EndpointResources.
+     */
+    EndpointResources& addDescriptionWithAssetId(const std::string& assetId);
+
+    /**
+     * Function to add description using text value and its locale.
+     *
+     * @note When using this method it is recommended to provide the description
+     * in all the Alexa supported languages. See the class-level link to find the currently
+     * supported languages.
+     *
+     * @note Providing an unsupported locale will result in Discovery failure.
+     *
+     * @param text The text of the description. This value can contain up to 128 valid characters.
+     * @param locale The non-empty locale of the description.
+     * @return This instance to facilitate setting more information to this EndpointResources.
+     */
+    EndpointResources& addDescriptionWithText(
+            const std::string& text,
+            const avsCommon::avs::Locale& locale);
+
+    /**
+     * Function to check if the @c EndpointResources is valid.
+     *
+     * @return Return @c true if valid, otherwise @c false.
+     */
+     bool isValid() const;
+
+    /**
+     * Builds a new EndpointResources with the configured properties.
+     *
+     * Build will fail if any attribute is invalid or if a mandatory attribute is missing.
+     *
+     * @return A json string representing the EndpointResources; otherwise, an empty string.
+     */
+     std::string build() const;
+
+private:
+    /**
+     * Struct defining a Label, used to describe a resource.
+     * @see https://developer.amazon.com/docs/device-apis/resources-and-assets.html#capability-resources
+     */
+    struct Label {
+        /// The enum representing the Label type.
+        enum class LabelType {
+            /// Asset type.
+            ASSET,
+
+            /// Text type.
+            TEXT
+        };
+
+        /// The type of the Label. 
+        LabelType type;
+
+        /// The value to contain the text or the asset id of the friendly name, manufacturer name or description.
+        std::string value;
+
+        /// The locale of the text, and empty object for asset.
+        avsCommon::utils::Optional<avsCommon::avs::Locale> locale;
+
+        /**
+         *  @name Comparison operator.
+         *
+         *  Compare the current Label against a second object.
+         *  Defined for std::find.
+         *
+         *  @param rhs The object to compare against this.
+         *  @return @c true if the comparison holds; @c false otherwise.
+         */
+        /// @{
+        bool operator==(const Label& rhs) const;
+        /// @}
+
+        /**
+         * Helper function to convert a Label to a json string.
+         *
+         * @return A json string of Label.
+         */
+        std::string toJson() const;
+    };
+
+    /// Flag to indicate if there was any error noted.
+    bool m_isValid = false;
+
+    /// Vector holding @c Label for the friendly names.
+    std::vector<Label> m_friendlyNames;
+
+    /// @c Label that holds the manufacturer name.
+    Label m_manufacturerName;
+
+    /// @c Label that holds the description.
+    Label m_description;
+};
+
+}  // namespace avs
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif //ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_ENDPOINTRESOURCES_H_
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/Locale.h b/AVSCommon/AVS/include/AVSCommon/AVS/Locale.h
new file mode 100644
index 00000000..5f7cece6
--- /dev/null
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/Locale.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_LOCALE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_LOCALE_H_
+
+#include <string>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace avs {
+
+    /**
+     * Alias for the locale. The locale should follow <a href="https://tools.ietf.org/html/bcp47">BCP 47 format</a> and
+     * it's composed of a language tag and a region tag, e.g.: en-CA.
+     */
+    using Locale = std::string;
+
+
+}  // namespace avs
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_LOCALE_H_
diff --git a/AVSCommon/AVS/src/DialogUXStateAggregator.cpp b/AVSCommon/AVS/src/DialogUXStateAggregator.cpp
index e4ad4650..d83b7f77 100644
--- a/AVSCommon/AVS/src/DialogUXStateAggregator.cpp
+++ b/AVSCommon/AVS/src/DialogUXStateAggregator.cpp
@@ -101,13 +101,18 @@ DialogUXStateAggregator::DialogUXStateAggregator(
         m_shortTimeoutForThinkingToIdle{shortTimeoutForThinkingToIdle},
         m_timeoutForListeningToIdle{timeoutForListeningToIdle},
         m_speechSynthesizerState{SpeechSynthesizerObserverInterface::SpeechSynthesizerState::FINISHED},
-        m_audioInputProcessorState{AudioInputProcessorObserverInterface::State::IDLE} {
+        m_audioInputProcessorState{AudioInputProcessorObserverInterface::State::IDLE},
+        m_continueWithInvalidTransition{false} {
     ACSDK_DEBUG8(LX("timeout values in milliseconds")
                      .d("m_timeoutForThinkingToIdle", m_timeoutForThinkingToIdle.count())
                      .d("m_shortTimeoutForThinkingToIdle", m_shortTimeoutForThinkingToIdle.count())
                      .d("m_timeoutForListeningToIdle", m_timeoutForListeningToIdle.count()));
 }
 
+void DialogUXStateAggregator::setContinueWithInvalidTransition(bool continueWithInvalidTransition) {
+    m_continueWithInvalidTransition = continueWithInvalidTransition;
+}
+
 void DialogUXStateAggregator::addObserver(std::shared_ptr<DialogUXStateObserverInterface> observer) {
     if (!observer) {
         ACSDK_ERROR(LX("addObserverFailed").d("reason", "nullObserver"));
@@ -145,8 +150,7 @@ void DialogUXStateAggregator::onStateChanged(AudioInputProcessorObserverInterfac
                 executeSetState(DialogUXStateObserverInterface::DialogUXState::EXPECTING);
                 return;
             case AudioInputProcessorObserverInterface::State::BUSY:
-                if (executeSetState(DialogUXStateObserverInterface::DialogUXState::LISTENING) ||
-                    DialogUXStateObserverInterface::DialogUXState::LISTENING == m_currentState) {
+                if (DialogUXStateObserverInterface::DialogUXState::LISTENING == m_currentState) {
                     if (!m_listeningTimeoutTimer
                              .start(
                                  m_timeoutForListeningToIdle,
@@ -314,17 +318,6 @@ bool DialogUXStateAggregator::executeSetState(sdkInterfaces::DialogUXStateObserv
 
     if (newState == m_currentState) {
         validTransition = false;
-    } else {
-        switch (m_currentState) {
-            case DialogUXStateObserverInterface::DialogUXState::THINKING:
-                if (DialogUXStateObserverInterface::DialogUXState::LISTENING == newState) {
-                    validTransition = false;
-                }
-
-                break;
-            default:
-                break;
-        }
     }
 
     ACSDK_DEBUG0(LX(__func__)
@@ -333,7 +326,12 @@ bool DialogUXStateAggregator::executeSetState(sdkInterfaces::DialogUXStateObserv
                      .d("validTransition", validTransition ? "true" : "false"));
 
     if (!validTransition) {
-        return false;
+        if (!m_continueWithInvalidTransition) {
+            return false;
+        } else {
+            ACSDK_DEBUG0(LX(__func__)
+                .m("validTransition is false but continue"));
+        }
     }
 
     m_listeningTimeoutTimer.stop();
diff --git a/AVSCommon/AVS/src/EndpointResources.cpp b/AVSCommon/AVS/src/EndpointResources.cpp
new file mode 100644
index 00000000..f946b416
--- /dev/null
+++ b/AVSCommon/AVS/src/EndpointResources.cpp
@@ -0,0 +1,221 @@
+/*
+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <algorithm>
+
+#include <AVSCommon/AVS/EndpointResources.h>
+#include <AVSCommon/Utils/JSON/JSONGenerator.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace avs {
+
+using namespace avsCommon::utils;
+
+/// String to identify log entries originating from this file.
+static const std::string TAG("EndpointResources");
+
+/**
+* Create a LogEntry using this file's TAG and the specified event string.
+*
+* @param The event string for this @c LogEntry.
+*/
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+/// Maximum length of the friendly name
+static constexpr size_t MAX_FRIENDLY_NAME_LENGTH = 128;
+/// Maximum length of the manufacturer name
+static constexpr size_t MAX_MANUFACTURER_NAME_LENGTH = 128;
+/// Maximum length of the description
+static constexpr size_t MAX_DESCRIPTION_LENGTH = 128;
+
+EndpointResources::EndpointResources() : m_isValid{true} {
+}
+
+bool EndpointResources::Label::operator==(const EndpointResources::Label& rhs) const {
+    return value == rhs.value && locale.valueOr("") == rhs.locale.valueOr("");
+}
+
+EndpointResources& EndpointResources::addFriendlyNameWithAssetId(const std::string& assetId) {
+    if (assetId.length() == 0) {
+        ACSDK_ERROR(LX("addFriendlyNameWithAssetIdFailed").d("reason", "invalidAssetId"));
+        m_isValid = false;
+        return *this;
+    }
+
+    if (std::find(
+            m_friendlyNames.begin(),
+            m_friendlyNames.end(),
+            EndpointResources::Label(
+                    {Label::LabelType::ASSET, assetId, utils::Optional<avsCommon::avs::Locale>()})) != m_friendlyNames.end()) {
+        ACSDK_ERROR(LX("addFriendlyNameWithAssetIdFailed").d("reason", "duplicateAssetId").sensitive("assetId", assetId));
+        m_isValid = false;
+        return *this;
+    }
+
+    m_friendlyNames.push_back({Label::LabelType::ASSET, assetId, utils::Optional<avsCommon::avs::Locale>()});
+
+    return *this;
+};
+
+EndpointResources& EndpointResources::addFriendlyNameWithText(
+        const std::string& text,
+        const avsCommon::avs::Locale& locale) {
+
+        if (text.length() == 0 || text.length() > MAX_FRIENDLY_NAME_LENGTH) {
+            ACSDK_ERROR(LX("addFriendlyNameWithTextFailed").d("reason", "invalidText"));
+            m_isValid = false;
+        }
+        if (locale.empty()) {
+            ACSDK_ERROR(LX("addFriendlyNameWithTextFailed").d("reason", "invalidLocale"));
+            m_isValid = false;
+        }
+        if (std::find(
+                m_friendlyNames.begin(),
+                m_friendlyNames.end(),
+                Label({Label::LabelType::TEXT, text, Optional<avsCommon::avs::Locale>(locale)})) !=
+                m_friendlyNames.end()) {
+            ACSDK_ERROR(LX("addFriendlyNameWithTextFailed")
+                                .d("reason", "duplicateText")
+                                .sensitive("text", text)
+                                .sensitive("locale", locale));
+            m_isValid = false;
+        }
+
+        m_friendlyNames.push_back({Label::LabelType::TEXT, text, Optional<avsCommon::avs::Locale>(locale)});
+
+    return *this;
+};
+
+EndpointResources& EndpointResources::addManufacturerNameWithAssetId(const std::string& assetId) {
+    if (assetId.length() == 0){
+        ACSDK_ERROR(LX("addManufacturerNameWithAssetIdFailed").d("reason", "invalidAssetId"));
+        m_isValid = false;
+        return *this;
+    }
+    if (m_manufacturerName.value.length() != 0){
+        ACSDK_ERROR(LX("addManufacturerNameWithAssetIdFailed").d("reason", "manufacturerNameAlreadyExists"));
+        m_isValid = false;
+        return *this;
+    }
+
+    m_manufacturerName = {Label::LabelType::ASSET, assetId, Optional<avsCommon::avs::Locale>()};
+
+    return *this;
+};
+
+EndpointResources& EndpointResources::addManufacturerNameWithText(
+        const std::string& text,
+        const avsCommon::avs::Locale& locale) {
+
+    if (text.length() == 0 || text.length() > MAX_MANUFACTURER_NAME_LENGTH) {
+        ACSDK_ERROR(LX("addManufacturerNameWithTextFailed").d("reason", "invalidText"));
+        m_isValid = false;
+    }
+    if (locale.empty()) {
+        ACSDK_ERROR(LX("addManufacturerNameWithTextFailed").d("reason", "invalidLocale"));
+        m_isValid = false;
+    }
+    if (m_manufacturerName.value.length() != 0){
+        ACSDK_ERROR(LX("addManufacturerNameWithAssetIdFailed").d("reason", "manufacturerNameAlreadyExists"));
+        m_isValid = false;
+        return *this;
+    }
+
+    m_manufacturerName = {Label::LabelType::TEXT, text, Optional<avsCommon::avs::Locale>(locale)};
+    return *this;
+};
+
+
+EndpointResources& EndpointResources::addDescriptionWithAssetId(const std::string& assetId) {
+    if (assetId.length() == 0){
+        ACSDK_ERROR(LX("addDescriptionWithAssetIdFailed").d("reason", "invalidAssetId"));
+        m_isValid = false;
+        return *this;
+    }
+    if (m_description.value.length() != 0){
+        ACSDK_ERROR(LX("addDescriptionWithAssetIdFailed").d("reason", "descriptionAlreadyExists"));
+        m_isValid = false;
+        return *this;
+    }
+
+    m_description = {Label::LabelType::ASSET, assetId, Optional<avsCommon::avs::Locale>()};
+    return *this;
+};
+
+EndpointResources& EndpointResources::addDescriptionWithText(
+        const std::string& text,
+        const avsCommon::avs::Locale& locale) {
+
+    if (text.length() == 0 || text.length() > MAX_DESCRIPTION_LENGTH) {
+        ACSDK_ERROR(LX("addDescriptionWithTextFailed").d("reason", "invalidText"));
+        m_isValid = false;
+    }
+    if (locale.empty()) {
+        ACSDK_ERROR(LX("addDescriptionWithTextFailed").d("reason", "invalidLocale"));
+        m_isValid = false;
+    }
+    if (m_description.value.length() != 0){
+        ACSDK_ERROR(LX("addDescriptionWithAssetIdFailed").d("reason", "descriptionAlreadyExists"));
+        m_isValid = false;
+        return *this;
+    }
+
+    m_description = {Label::LabelType::TEXT, text, Optional<avsCommon::avs::Locale>(locale)};
+    return *this;
+};
+
+bool EndpointResources::isValid() const {
+    return m_isValid && m_friendlyNames.size() > 0 && m_description.value.length() > 0
+                     && m_manufacturerName.value.length() > 0;
+};
+
+std::string EndpointResources::build() const {
+    if (!isValid()) {
+        ACSDK_ERROR(LX("buildFailed").d("reason", "invalidEndpointResources"));
+        return "";
+    }
+    json::JsonGenerator jsonGenerator;
+    std::vector<std::string> friendlyNames;
+    for (auto &friendlyName : m_friendlyNames){
+        friendlyNames.push_back(friendlyName.toJson());
+    }
+    jsonGenerator.addMembersArray("friendlyNames", friendlyNames);
+    jsonGenerator.addRawJsonMember("manufacturerName", m_manufacturerName.toJson());
+    jsonGenerator.addRawJsonMember("description", m_description.toJson());
+    return jsonGenerator.toString();
+};
+
+std::string EndpointResources::Label::toJson() const {
+    json::JsonGenerator scopeGenerator;
+    if (type == Label::LabelType::TEXT) {
+        scopeGenerator.addMember("@type", "text");
+        scopeGenerator.startObject("value");
+        scopeGenerator.addMember("text", value);
+        scopeGenerator.addMember("locale", locale.value());
+    } else if (type == Label::LabelType::ASSET) {
+        scopeGenerator.addMember("@type", "asset");
+        scopeGenerator.startObject("value");
+        scopeGenerator.addMember("assetId", value);
+    } else{
+        return "{}";
+    }
+    return scopeGenerator.toString();
+};
+
+}  // namespace avs
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/AVS/test/DialogUXStateAggregatorTest.cpp b/AVSCommon/AVS/test/DialogUXStateAggregatorTest.cpp
index c85cbcb8..79cda924 100644
--- a/AVSCommon/AVS/test/DialogUXStateAggregatorTest.cpp
+++ b/AVSCommon/AVS/test/DialogUXStateAggregatorTest.cpp
@@ -227,19 +227,11 @@ TEST_F(DialogUXAggregatorTest, test_aipExpectingSpeechLeadsToListeningState) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::EXPECTING);
 }
 
-/// Tests that the AIP busy state leads to the LISTENING state.
-TEST_F(DialogUXAggregatorTest, test_aipBusyLeadsToListeningState) {
-    assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
-
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::BUSY);
-    assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
-}
-
 /// Tests that the RequestProcessingStarted leads to the THINKING state.
 TEST_F(DialogUXAggregatorTest, test_requestProcessingStartedLeadsToThinkingState) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::BUSY);
+    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
 
     m_aggregator->onRequestProcessingStarted();
@@ -255,6 +247,7 @@ TEST_F(DialogUXAggregatorTest, test_listeningGoesToIdleAfterTimeout) {
 
     assertStateChange(m_anotherTestObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
+    anotherAggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
     anotherAggregator->onStateChanged(AudioInputProcessorObserverInterface::State::BUSY);
     assertStateChange(m_anotherTestObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
 
@@ -269,7 +262,7 @@ TEST_F(DialogUXAggregatorTest, test_thinkingGoesToIdleAfterTimeout) {
     anotherAggregator->addObserver(m_anotherTestObserver);
     assertStateChange(m_anotherTestObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    anotherAggregator->onStateChanged(AudioInputProcessorObserverInterface::State::BUSY);
+    anotherAggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_anotherTestObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
 
     anotherAggregator->onRequestProcessingStarted();
@@ -282,7 +275,7 @@ TEST_F(DialogUXAggregatorTest, test_thinkingGoesToIdleAfterTimeout) {
 TEST_F(DialogUXAggregatorTest, test_thinkingThenReceiveGoesToIdleAfterLongTimeout) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::BUSY);
+    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
 
     m_aggregator->onRequestProcessingStarted();
@@ -299,7 +292,7 @@ TEST_F(DialogUXAggregatorTest, test_thinkingThenReceiveGoesToIdleAfterLongTimeou
 TEST_F(DialogUXAggregatorTest, test_listeningThenRequestProcessingCompletedThenSpeakGoesToSpeakButNotIdle) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::BUSY);
+    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
 
     m_aggregator->onRequestProcessingStarted();
@@ -322,7 +315,7 @@ TEST_F(DialogUXAggregatorTest, test_listeningThenRequestProcessingCompletedThenS
 TEST_F(DialogUXAggregatorTest, test_speakingAndRecognizingFinishedGoesToIdle) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::BUSY);
+    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
     m_aggregator->onRequestProcessingStarted();
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
@@ -351,7 +344,7 @@ TEST_F(DialogUXAggregatorTest, test_nonIdleObservantsPreventsIdle) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
     // AIP is active, SS is not. Expected: non idle
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::BUSY);
+    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
     m_aggregator->onStateChanged(
         SpeechSynthesizerObserverInterface::SpeechSynthesizerState::FINISHED,
         TEST_SOURCE_ID,
@@ -389,7 +382,7 @@ TEST_F(DialogUXAggregatorTest, test_nonIdleObservantsPreventsIdle) {
 TEST_F(DialogUXAggregatorTest, test_speakingFinishedDoesNotGoesToIdleImmediately) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::BUSY);
+    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
     m_aggregator->onRequestProcessingStarted();
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
@@ -439,7 +432,7 @@ TEST_F(DialogUXAggregatorTest, test_simpleReceiveDoesNothing) {
 TEST_F(DialogUXAggregatorTest, test_thinkingThenReceiveRemainsInThinkingIfSpeechSynthesizerReportsGainingFocus) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::BUSY);
+    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
     m_aggregator->onRequestProcessingStarted();
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
@@ -464,7 +457,7 @@ TEST_F(DialogUXAggregatorTest, test_validStatesForRPSToThinking) {
 
     m_aggregator->onRequestProcessingCompleted();
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::BUSY);
+    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
     m_aggregator->onRequestProcessingStarted();
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
@@ -498,7 +491,7 @@ TEST_F(DialogUXAggregatorTest, test_validStatesForRPSToThinking) {
 TEST_F(DialogUXAggregatorTest, test_receiveThenRPCTransitionsOutOfThinking) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::BUSY);
+    m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::RECOGNIZING);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
 
     m_aggregator->onRequestProcessingStarted();
diff --git a/AVSCommon/CMakeLists.txt b/AVSCommon/CMakeLists.txt
index 981fdb72..33d4bca9 100644
--- a/AVSCommon/CMakeLists.txt
+++ b/AVSCommon/CMakeLists.txt
@@ -26,6 +26,7 @@ add_library(AVSCommon SHARED
     AVS/src/ComponentConfiguration.cpp
     AVS/src/DialogUXStateAggregator.cpp
     AVS/src/DirectiveRoutingRule.cpp
+    AVS/src/EndpointResources.cpp
     AVS/src/EventBuilder.cpp
     AVS/src/ExceptionEncounteredSender.cpp
     AVS/src/CapabilityResources.cpp
@@ -60,6 +61,8 @@ add_library(AVSCommon SHARED
     Utils/src/LibcurlUtils/HTTPContentFetcherFactory.cpp
     Utils/src/LibcurlUtils/HttpPost.cpp
     Utils/src/LibcurlUtils/HttpPut.cpp
+    Utils/src/LibcurlUtils/HttpGet.cpp
+    Utils/src/LibcurlUtils/HttpDelete.cpp
     Utils/src/LibcurlUtils/HTTPResponse.cpp
     Utils/src/LibcurlUtils/LibCurlHttpContentFetcher.cpp
     Utils/src/LibcurlUtils/LibcurlHTTP2Connection.cpp
@@ -120,6 +123,7 @@ target_include_directories(AVSCommon PUBLIC
     "${AVSCommon_SOURCE_DIR}/AVS/include"
     "${AVSCommon_SOURCE_DIR}/SDKInterfaces/include"
     "${AVSCommon_SOURCE_DIR}/Utils/include"
+    "${AVSCommon_SOURCE_DIR}/../Captions/Interface/include"
     "${RAPIDJSON_INCLUDE_DIR}"
     "${MultipartParser_SOURCE_DIR}"
     ${CURL_INCLUDE_DIRS})
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Endpoints/EndpointBuilderInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Endpoints/EndpointBuilderInterface.h
index d22977fa..5af7c2b8 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Endpoints/EndpointBuilderInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Endpoints/EndpointBuilderInterface.h
@@ -19,10 +19,12 @@
 #include <memory>
 #include <string>
 
+#include "AVSCommon/AVS/EndpointResources.h"
 #include "AVSCommon/SDKInterfaces/CapabilityConfigurationInterface.h"
 #include "AVSCommon/SDKInterfaces/DirectiveHandlerInterface.h"
 #include "AVSCommon/SDKInterfaces/Endpoints/EndpointCapabilitiesBuilderInterface.h"
 #include "AVSCommon/SDKInterfaces/Endpoints/EndpointCapabilitiesRegistrarInterface.h"
+#include "AVSCommon/SDKInterfaces/Endpoints/EndpointIdentifier.h"
 #include "AVSCommon/SDKInterfaces/Endpoints/EndpointInterface.h"
 #include "AVSCommon/SDKInterfaces/ModeController/ModeControllerAttributes.h"
 #include "AVSCommon/SDKInterfaces/ModeController/ModeControllerInterface.h"
@@ -136,18 +138,32 @@ public:
      * @note This value can contain up to 128 characters.
      * @note The builder will fail if the manufacturer name param is invalid.
      *
-     * @param description The manufacturer name of the device representing the endpoint.
+     * @param manufacturerName The manufacturer name of the device representing the endpoint.
      * @return This builder which can be used to nest configuration function calls.
      */
     virtual EndpointBuilderInterface& withManufacturerName(const std::string& manufacturerName) = 0;
 
+    /**
+     * Configures builder to use endpointResources representing the endpoint.
+     *
+     * @note EndpointResources contains friendlyNames, manufacturer name and description.
+     * @note Use either withFriendlyName, withDescription, withManufacturerName to build or withEndpointResources
+     * to build. 
+     * @note The builder will fail if the endpointResources param is invalid.
+     *
+     * @param endpointResources The endpointResources of the device representing the endpoint.
+     * @return This builder which can be used to nest configuration function calls.
+     */
+    virtual EndpointBuilderInterface& withEndpointResources(
+            const avsCommon::avs::EndpointResources& endpointResources) = 0;
+
     /**
      * Configures builder to use the following display categories.
      *
      * @note This will override any previous display categories configuration.
      * @note The builder will fail if the displayCategories param is invalid.
      *
-     * @param description The display category the device belongs to.
+     * @param displayCategories The display category the device belongs to.
      * @return This builder which can be used to nest configuration function calls.
      */
     virtual EndpointBuilderInterface& withDisplayCategory(const std::vector<std::string>& displayCategories) = 0;
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/LocaleAssetsManagerInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/LocaleAssetsManagerInterface.h
index 18b1536d..2783ace4 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/LocaleAssetsManagerInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/LocaleAssetsManagerInterface.h
@@ -21,6 +21,7 @@
 #include <string>
 #include <vector>
 
+#include <AVSCommon/AVS/Locale.h>
 #include <AVSCommon/SDKInterfaces/CapabilityConfigurationChangeObserverInterface.h>
 #include <AVSCommon/SDKInterfaces/Endpoints/EndpointRegistrationManagerInterface.h>
 #include <AVSCommon/SDKInterfaces/LocaleAssetsObserverInterface.h>
@@ -40,10 +41,9 @@ namespace sdkInterfaces {
 class LocaleAssetsManagerInterface : public CapabilityConfigurationChangeObserverInterface {
 public:
     /**
-     * Alias for the locale. The locale should follow <a href="https://tools.ietf.org/html/bcp47">BCP 47 format</a> and
-     * it's composed of a language tag and a region tag, e.g.: en-CA.
+     *  Alias for Locale.
      */
-    using Locale = std::string;
+    using Locale = avsCommon::avs::Locale;
 
     /**
      * Alias for the language tag. The language tag should follow <a href="https://tools.ietf.org/html/bcp47">BCP 47
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Messaging/MessagingObserverInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Messaging/MessagingObserverInterface.h
new file mode 100644
index 00000000..80258547
--- /dev/null
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Messaging/MessagingObserverInterface.h
@@ -0,0 +1,129 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_MESSAGING_MESSAGINGOBSERVERINTERFACE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_MESSAGING_MESSAGINGOBSERVERINTERFACE_H_
+
+#include <string>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace sdkInterfaces {
+namespace messaging {
+
+/**
+ * This @c MessagingObserverInterface class is used to notify observers when a @c SendMessage,
+ * @c UpdateMessageStatus, or @c UploadConversations directive is received.
+ */
+class MessagingObserverInterface {
+public:
+    /**
+     * An enum representing the messaging endpoints.
+     */
+    enum class MessagingEndpoint {
+        /// Default messaging endpoint
+        DEFAULT
+    };
+
+    /**
+     * Destructor
+     */
+    virtual ~MessagingObserverInterface() = default;
+
+    /**
+     * Used to notify the observer when a @c Alexa.Comms.MessagingController.SendMessage directive
+     * is received. Once called, the client should send the message to the given recipients
+     * using the specified messaging endpoint.
+     *
+     * @param token The token for this request.
+     * @param endpoint The messaging endpoint to send the message.
+     * @param jsonPayload The payload of the @c SendMessage directive in structured JSON format.
+     * @code{.json}
+     * {
+     *     "payload": {
+     *         "@type" : "text",
+     *         "text" : "{{STRING}}"
+     *     },
+     *     "recipients" : [
+     *         {
+     *             "address" : "{{STRING}}",
+     *             "addressType" : "PhoneNumberAddress"
+     *         }
+     *     ]
+     * }
+     * @endcode
+     *
+     */
+    virtual void sendMessage(const std::string& token, MessagingEndpoint endpoint, const std::string& jsonPayload) = 0;
+
+    /**
+     * Used to notify the observer when a @c Alexa.Comms.MessagingController.UploadConversations directive
+     * is received. Once called, the client should upload a conversations report using the specified
+     * filter in the JSON payload.
+     *
+     * @param token The token for this request.
+     * @param endpoint The messaging endpoint whose messages are requested to be uploaded.
+     * @param jsonPayload The payload of the @c UploadConversations directive in structured JSON format. The only
+     * supported filter values are shown below.
+     * @code{.json}
+     * {
+     *     "filter" : {
+     *         "conversationFilter" : {
+     *             "@type" : "AllConversations",
+     *             "conversationIds" : [{{STRING}}]
+     *         },
+     *         "messageFilter" : {
+     *             "@type" : "UnreadMessages"
+     *         },
+     *         "maxMessageCount" : 40
+     *      }
+     * }
+     * @endcode
+     *
+     */
+    virtual void uploadConversations(
+        const std::string& token,
+        MessagingEndpoint endpoint,
+        const std::string& jsonPayload) = 0;
+
+    /**
+     * Used to notify the observer when a @c Alexa.Comms.MessagingController.UpdateMessagesStatus directive
+     * is received. Once called, the client should update the specified messages with the given
+     * status.
+     *
+     * @param token The token for this request.
+     * @param endpoint The messaging endpoint whose messages status need to be updated.
+     * @param jsonPayload The payload of the @c UpdateMessagesStatus directive in structured JSON format.
+     * @code{.json}
+     * {
+     *     "conversationId" : {{STRING}},
+     *     "statusMap" : {
+     *         "read" : [{{STRING}}],
+     *     }
+     * }
+     * @endcode
+     */
+    virtual void updateMessagesStatus(
+        const std::string& token,
+        MessagingEndpoint endpoint,
+        const std::string& jsonPayload) = 0;
+};
+
+}  // namespace messaging
+}  // namespace sdkInterfaces
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_MESSAGING_MESSAGINGOBSERVERINTERFACE_H_
\ No newline at end of file
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h
index aa9cb8d1..cfff6fe2 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h
@@ -95,7 +95,9 @@ public:
         /// HTTP POST
         kPOST,
         /// HTTP PUT
-        kPUT
+        kPUT,
+        /// HTTP DELETE
+        kDELETE
     };
 
     /**
@@ -280,9 +282,9 @@ public:
      * connection.
      *
      * Network interface provided will be used in preference over the value
-     * in provided in config. Set emtpy string to reset to default.
+     * in provided in config. Set empty string to reset to default.
      *
-     * @note The network interace set shall applied only to newly instantiated
+     * @note The network interface set shall applied only to newly instantiated
      * @c CurlEasyHandleWrapper objects.
      *
      * @param value The interface name as defined in CURLOPT_INTERFACE.
@@ -298,6 +300,25 @@ public:
 
     CurlEasyHandleWrapperOptionsSettingAdapter& curlOptionsSetter();
 
+    /**
+     * Static function to set custom HTTP headers to pass in the HTTP request sent to a proxy, for example:
+     *
+     * "Proxy-Authorization: Bearer 1234" (should not be CRLF-terminated)
+     *
+     * The specified headers will be applied to all subsequent requests sent to a proxy. They will not be applied
+     * if there is no proxy specified by `CURLOPT_PROXY` in the config.
+     *
+     * @param headers the list of headers. See https://curl.se/libcurl/c/CURLOPT_HTTPHEADER.html for detailed rules about the header.
+     */
+    static void setProxyHeaders(const std::vector<std::string>& headers);
+
+    /**
+     * Static function to get custom HTTP headers to pass in the HTTP request sent to a proxy.
+     *
+     * @returns the list of headers.
+     */
+    static std::vector<std::string> getProxyHeaders();
+
 private:
     /**
      * Helper function for calling curl_easy_setopt and checking the result.
@@ -369,17 +390,22 @@ private:
     curl_httppost* m_lastPost;
     /// Name for this handle.
     std::string m_id;
-    /// Synchronizes access to the @c m_interfaceName
-    static std::mutex m_interfaceNameMutex;
+    /// Synchronizes access to the settings e.g. @c s_interfaceName or @c s_proxyHeaders
+    static std::mutex s_settingsMutex;
     /// Indicates the initialization of @c m_interfaceName
-    static bool m_isInterfaceNameInitialized;
+    static bool s_isInterfaceNameInitialized;
     /// Interface name to be used for curl
-    static std::string m_interfaceName;
+    static std::string s_interfaceName;
     /// If no id is provided by the user, we will generate it from this counter.
-    static std::atomic<uint64_t> m_idGenerator;
+    static std::atomic<uint64_t> s_idGenerator;
 
     CurlEasyHandleWrapperOptionsSettingAdapter m_curlOptionsSettingAdapter;
 
+    /// Custom HTTP headers provided by setProxyHeaders call.
+    static std::vector<std::string> s_proxyHeaders;
+    /// A list of headers needed to be added to a proxy request
+    curl_slist* m_proxyHeaders;
+
     friend class CurlEasyHandleWrapperOptionsSettingAdapter;
 };
 
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDelete.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDelete.h
new file mode 100644
index 00000000..bff624b6
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDelete.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETE_H_
+
+#include <memory>
+#include <mutex>
+#include <string>
+
+#include <curl/curl.h>
+
+#include "AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h"
+#include "HttpDeleteInterface.h"
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+/// LIBCURL based implementation of HttpDeleteInterface.
+class HttpDelete : public HttpDeleteInterface {
+public:
+    /**
+     * Create a new HttpDelete instance, passing ownership of the new instance on to the caller.
+     *
+     * @return Returns an std::unique_ptr to the new HttpDelete instance, or @c nullptr of the operation failed.
+     */
+    static std::unique_ptr<HttpDelete> create();
+
+    /**
+     * HttpDelete destructor
+     */
+    ~HttpDelete() = default;
+
+    /**
+     * Deleted copy constructor.
+     *
+     * @param rhs The 'right hand side' to not copy.
+     */
+    HttpDelete(const HttpDelete& rhs) = delete;
+
+    /**
+     * Deleted assignment operator.
+     *
+     * @param rhs The 'right hand side' to not copy.
+     * @return The object assigned to.
+     */
+    HttpDelete& operator=(const HttpDelete& rhs) = delete;
+
+    HTTPResponse doDelete(const std::string& url, const std::vector<std::string>& headers, std::chrono::seconds timeout) override;
+
+private:
+    /**
+     * Default HttpDelete constructor.
+     */
+    HttpDelete() = default;
+
+    /// Mutex to serialize access to @c m_curl.
+    std::mutex m_mutex;
+
+    /// CURL handle with which to make requests
+    CurlEasyHandleWrapper m_curl;
+};
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETE_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDeleteInterface.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDeleteInterface.h
new file mode 100644
index 00000000..14459fa6
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDeleteInterface.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETEINTERFACE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETEINTERFACE_H_
+
+#include <chrono>
+#include <string>
+#include <vector>
+
+#include <AVSCommon/Utils/LibcurlUtils/HTTPResponse.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+/// Minimal interface for making HTTP DELETE requests.
+class HttpDeleteInterface {
+public:
+    /// Virtual destructor to assure proper cleanup of derived types.
+    virtual ~HttpDeleteInterface() = default;
+
+    /**
+     * Perform an HTTP DELETE request returning the response body as a string. This method blocks for the duration
+     * of the request.
+     *
+     * @param url The URL to send the DELETE to.
+     * @param headers vector of strings to add in the header.
+     * @param timeout The maximum amount of time (in seconds) to wait for the request to complete.
+     * @return An object describing the response to the DELETE request.
+     */
+    virtual HTTPResponse doDelete(
+        const std::string& url,
+        const std::vector<std::string>& headers,
+        std::chrono::seconds timeout) = 0;
+};
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETEINTERFACE_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGet.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGet.h
new file mode 100644
index 00000000..58099ed9
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGet.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGET_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGET_H_
+
+#include <memory>
+#include <mutex>
+#include <string>
+
+#include <curl/curl.h>
+
+#include "AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h"
+#include "HttpGetInterface.h"
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+/// LIBCURL based implementation of HttpGetInterface.
+class HttpGet : public HttpGetInterface {
+public:
+    /**
+     * Create a new HttpGet instance, passing ownership of the new instance on to the caller.
+     *
+     * @return Returns an std::unique_ptr to the new HttpGet instance, or @c nullptr of the operation failed.
+     */
+    static std::unique_ptr<HttpGet> create();
+
+    /**
+     * HttpGet destructor
+     */
+    ~HttpGet() = default;
+
+    /**
+     * Deleted copy constructor.
+     *
+     * @param rhs The 'right hand side' to not copy.
+     */
+    HttpGet(const HttpGet& rhs) = delete;
+
+    /**
+     * Deleted assignment operator.
+     *
+     * @param rhs The 'right hand side' to not copy.
+     * @return The object assigned to.
+     */
+    HttpGet& operator=(const HttpGet& rhs) = delete;
+
+    HTTPResponse doGet(const std::string& url, const std::vector<std::string>& headers, std::chrono::seconds timeout = std::chrono::minutes(1)) override;
+
+private:
+    /**
+     * Default HttpGet constructor.
+     */
+    HttpGet() = default;
+
+    /// Mutex to serialize access to @c m_curl.
+    std::mutex m_mutex;
+
+    /// CURL handle with which to make requests
+    CurlEasyHandleWrapper m_curl;
+};
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGET_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGetInterface.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGetInterface.h
index d76d0c45..b3fa11f1 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGetInterface.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGetInterface.h
@@ -16,6 +16,7 @@
 #ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGETINTERFACE_H_
 #define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGETINTERFACE_H_
 
+#include <chrono>
 #include <string>
 #include <vector>
 
@@ -38,9 +39,13 @@ public:
      *
      * @param url The URL to send the GET to.
      * @param headers Collection of strings to add in the header.
+     * @param timeout The maximum amount of time (in seconds) to wait for the request to complete.
      * @return An object describing the response to the GET request.
      */
-    virtual HTTPResponse doGet(const std::string& url, const std::vector<std::string>& headers) = 0;
+    virtual HTTPResponse doGet(
+        const std::string& url,
+        const std::vector<std::string>& headers,
+        std::chrono::seconds timeout = std::chrono::minutes(1)) = 0;
 };
 
 }  // namespace libcurlUtils
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/LibcurlUtils.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/LibcurlUtils.h
index e7582d94..7c792d5a 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/LibcurlUtils.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/LibcurlUtils.h
@@ -45,7 +45,7 @@ namespace libcurlUtils {
 bool prepareForTLS(CURL* handle);
 
 /**
- * Prepare a CURL handle to set the proxy to use for the upcoming request.
+ * Prepare a CURL handle to set the proxy to use for the upcoming requests.
  *
  * The 'libCurlUtils' sub-component of the global configuration supports the following options:
  * - CURLOPT_PROXY If present, specifies a value for the libcurl property CURLOPT_PROXY.
@@ -61,9 +61,10 @@ bool prepareForTLS(CURL* handle);
  * @endcode
  *
  * @param handle The libcurl handle to prepare.
+ * @param headers Additional headers for proxy request.
  * @return Whether the operation was successful.
  */
-bool prepareForProxy(CURL* handle);
+bool prepareForProxy(CURL* handle, curl_slist* headers = NULL);
 
 }  // namespace libcurlUtils
 }  // namespace utils
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/Logger/ThreadMoniker.h b/AVSCommon/Utils/include/AVSCommon/Utils/Logger/ThreadMoniker.h
index ec70c280..758a213d 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/Logger/ThreadMoniker.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/Logger/ThreadMoniker.h
@@ -39,7 +39,7 @@ public:
      *
      * @return The moniker for @c std::this_thread.
      */
-    static inline std::string getThisThreadMoniker();
+    static inline const char* getThisThreadMoniker();
 
     /**
      * Generate a unique moniker.
@@ -52,7 +52,8 @@ public:
      * Set the moniker for @c std::this_thread. This method should be called before @c getThisThreadMoniker() in order
      * to take effect.
      *
-     * @param moniker The moniker for @c std::this_thread.
+     * @param moniker The moniker for @c std::this_thread. The maximum length of the moniker is 15 characters. Any
+     * characters beyond the limit will be truncated.
      */
     static inline void setThisThreadMoniker(const std::string& moniker);
 
@@ -81,10 +82,10 @@ private:
     static const ThreadMoniker& getMonikerObjectFromMap(const std::string& moniker = std::string());
 
     /// The current thread's moniker.
-    std::string m_moniker;
+    char m_moniker[16];
 };
 
-std::string ThreadMoniker::getThisThreadMoniker() {
+const char* ThreadMoniker::getThisThreadMoniker() {
     return getMonikerObject().m_moniker;
 }
 
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/MediaPlayer/MediaDescription.h b/AVSCommon/Utils/include/AVSCommon/Utils/MediaPlayer/MediaDescription.h
index 26be2a0a..a3fe10ec 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/MediaPlayer/MediaDescription.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/MediaPlayer/MediaDescription.h
@@ -17,6 +17,13 @@
 #define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_MEDIAPLAYER_MEDIADESCRIPTION_H_
 
 #include <unordered_map>
+#include <vector>
+
+#include <AVSCommon/AVS/PlayBehavior.h>
+#include <AVSCommon/SDKInterfaces/Audio/MixingBehavior.h>
+#include <AVSCommon/Utils/AudioAnalyzer/AudioAnalyzerState.h>
+#include <AVSCommon/Utils/Optional.h>
+#include <Captions/CaptionData.h>
 
 namespace alexaClientSDK {
 namespace avsCommon {
@@ -30,8 +37,29 @@ static std::string PLAY_BEHAVIOR = "playBehavior";
  * An object that contains all playback related information needed from the media CA.
  */
 struct MediaDescription {
+    /// Media session identifier passed down from the media CA
+    std::string mediaSessionId;
+
+    /// Mixing behavior of the stream.
+    sdkInterfaces::audio::MixingBehavior mixingBehavior;
+
+    /// Focus channel identifies the content type acquiring focus following FocusManger naming convention.
+    std::string focusChannel;  // "Dialog", "Communications", "Alert", "Content", "Visual"
+
+    /// String identifier of the source.
+    std::string trackId;
+
+    /// Object that contains CaptionData with unprocessed caption content and metadata of a particular format.
+    Optional<captions::CaptionData> caption;
+
+    /// Audio analyzers used to process provided audio content.
+    Optional<std::vector<audioAnalyzer::AudioAnalyzerState>> analyzers;
+
     /// All additional information to be provided, including PlayBehavior.
     std::unordered_map<std::string, std::string> additionalData;
+
+    /// Are all of the required values in the Media Description struct set
+    bool enabled;
 };
 
 /**
@@ -39,7 +67,14 @@ struct MediaDescription {
  * @return an empty Media Description object.
  */
 inline MediaDescription emptyMediaDescription() {
-    return MediaDescription{{}};
+    return MediaDescription{"",
+                            sdkInterfaces::audio::MixingBehavior(),
+                            "",
+                            "",
+                            Optional<captions::CaptionData>(),
+                            Optional<std::vector<audioAnalyzer::AudioAnalyzerState>>(),
+                            {},
+                            false};
 }
 
 /**
@@ -50,12 +85,37 @@ inline MediaDescription emptyMediaDescription() {
  * @return The stream that was passed in and written to.
  */
 inline std::ostream& operator<<(std::ostream& stream, const MediaDescription& mediaDescription) {
-    stream << "AdditionalData:{";
+    stream << "MediaSessionId:" << mediaDescription.mediaSessionId << ", MixingBehavior:";
+    switch (mediaDescription.mixingBehavior) {
+        case sdkInterfaces::audio::MixingBehavior::BEHAVIOR_PAUSE:
+            stream << "BEHAVIOR_PAUSE";
+            break;
+        case sdkInterfaces::audio::MixingBehavior::BEHAVIOR_DUCK:
+            stream << "BEHAVIOR_DUCK";
+            break;
+    }
+    stream << ", Channel:" << mediaDescription.focusChannel << ", ";
+    stream << ", TrackId:" << mediaDescription.trackId;
+    if (mediaDescription.caption.hasValue()) {
+        stream << ", CaptionData:{format:" << (mediaDescription.caption.value()).format;
+        stream << ", content:" << (mediaDescription.caption.value()).content << "}";
+    }
+    if (mediaDescription.analyzers.hasValue()) {
+        stream << ", Analyzers:{";
+        const auto analyzersCopy = mediaDescription.analyzers.value();
+        for (auto iter = analyzersCopy.begin(); iter != analyzersCopy.end(); iter++) {
+            stream << "{name:" << (*iter).name;
+            stream << ", enableState:" << (*iter).enableState << "}";
+        }
+        stream << "}";
+    }
+    stream << ", AdditionalData:{";
     const auto additionalDataCopy = mediaDescription.additionalData;
     for (auto iter = additionalDataCopy.begin(); iter != additionalDataCopy.end(); iter++) {
         stream << "{" << (*iter).first;
         stream << ":" << (*iter).second << "}";
     }
+    stream << "}, enabled: " << (mediaDescription.enabled ? "true" : "false") << " }";
     return stream;
 }
 
diff --git a/AVSCommon/Utils/src/LibcurlUtils/CurlEasyHandleWrapper.cpp b/AVSCommon/Utils/src/LibcurlUtils/CurlEasyHandleWrapper.cpp
index 36e46ca5..b27c9c4b 100644
--- a/AVSCommon/Utils/src/LibcurlUtils/CurlEasyHandleWrapper.cpp
+++ b/AVSCommon/Utils/src/LibcurlUtils/CurlEasyHandleWrapper.cpp
@@ -53,13 +53,15 @@ static const std::string LIBCURLUTILS_CONFIG_KEY = "libcurlUtils";
 /// Key for looking up a configuration value for @c CURLOPT_INTERFACE
 static const std::string INTERFACE_CONFIG_KEY = "CURLOPT_INTERFACE";
 /// Counter used to geneate unique IDs.
-std::atomic<uint64_t> CurlEasyHandleWrapper::m_idGenerator{1};
+std::atomic<uint64_t> CurlEasyHandleWrapper::s_idGenerator{1};
 ///  Interface used for the curl connection.
-std::string CurlEasyHandleWrapper::m_interfaceName{""};
-/// Indicates the initialization of @c m_interfaceName
-bool CurlEasyHandleWrapper::m_isInterfaceNameInitialized = false;
-/// Synchronizes access to the @c m_interfaceName
-std::mutex CurlEasyHandleWrapper::m_interfaceNameMutex;
+std::string CurlEasyHandleWrapper::s_interfaceName{""};
+/// Indicates the initialization of @c s_interfaceName
+bool CurlEasyHandleWrapper::s_isInterfaceNameInitialized = false;
+/// Synchronizes access to the settings e.g. @c s_interfaceName or @c s_proxyHeaders
+std::mutex CurlEasyHandleWrapper::s_settingsMutex;
+/// HTTP headers for proxy request
+std::vector<std::string> CurlEasyHandleWrapper::s_proxyHeaders{};
 
 #ifdef ACSDK_EMIT_CURL_LOGS
 /// Key under 'acl' configuration node for path/prefix of per-stream log file names.
@@ -135,12 +137,13 @@ CurlEasyHandleWrapper::CurlEasyHandleWrapper(std::string id) :
         m_postHeaders{nullptr},
         m_post{nullptr},
         m_lastPost{nullptr},
-        m_curlOptionsSettingAdapter{this} {
+        m_curlOptionsSettingAdapter{this},
+        m_proxyHeaders{nullptr} {
     if (m_handle == nullptr) {
         ACSDK_ERROR(LX("CurlEasyHandleWrapperFailed").d("reason", "curl_easy_init failed"));
     } else {
         if (id.empty()) {
-            m_id = std::to_string(m_idGenerator++);
+            m_id = std::to_string(s_idGenerator++);
         } else {
             m_id = std::move(id);
         }
@@ -157,7 +160,7 @@ CurlEasyHandleWrapper::~CurlEasyHandleWrapper() {
 
 bool CurlEasyHandleWrapper::reset(std::string id) {
     if (id.empty()) {
-        m_id = std::to_string(m_idGenerator++);
+        m_id = std::to_string(s_idGenerator++);
     } else {
         m_id = std::move(id);
     }
@@ -249,6 +252,9 @@ bool CurlEasyHandleWrapper::setTransferType(TransferType type) {
         case TransferType::kPUT:
             ret = setopt(CURLOPT_UPLOAD, 1L);
             break;
+        case TransferType::kDELETE:
+            ret = setopt(CURLOPT_CUSTOMREQUEST, "DELETE");
+            break;
     }
     return ret;
 }
@@ -258,7 +264,7 @@ bool CurlEasyHandleWrapper::setTransferTimeout(const long timeoutSeconds) {
 }
 
 bool CurlEasyHandleWrapper::setPostData(const std::string& data) {
-    return setopt(CURLOPT_POSTFIELDS, data.c_str());
+    return setopt(CURLOPT_POSTFIELDS, data.c_str()) && setopt(CURLOPT_POSTFIELDSIZE_LARGE, (curl_off_t) data.size());
 }
 
 bool CurlEasyHandleWrapper::setConnectionTimeout(const std::chrono::seconds timeoutSeconds) {
@@ -303,6 +309,11 @@ void CurlEasyHandleWrapper::cleanupResources() {
         m_post = nullptr;
         m_lastPost = nullptr;
     }
+
+    if (m_proxyHeaders) {
+        curl_slist_free_all(m_proxyHeaders);
+        m_proxyHeaders = nullptr;
+    }
 }
 
 bool CurlEasyHandleWrapper::setDefaultOptions() {
@@ -321,11 +332,6 @@ bool CurlEasyHandleWrapper::setDefaultOptions() {
             break;
         }
 
-        if (!prepareForProxy(m_handle)) {
-            ACSDK_ERROR(LX("setDefaultOptions").d("reason", "prepareForProxy failed"));
-            break;
-        }
-
         /*
          * The documentation from libcurl recommends setting CURLOPT_NOSIGNAL to 1 for multi-threaded applications.
          * https://curl.haxx.se/libcurl/c/threadsafe.html
@@ -335,13 +341,24 @@ bool CurlEasyHandleWrapper::setDefaultOptions() {
         }
 
         {
-            std::lock_guard<std::mutex> lock(m_interfaceNameMutex);
-            if (!m_isInterfaceNameInitialized) {
+            std::lock_guard<std::mutex> lock(s_settingsMutex);
+            if (!s_isInterfaceNameInitialized) {
                 initializeNetworkInterfaceNameLocked();
             }
+
+            curl_slist_free_all(m_proxyHeaders);
+            m_proxyHeaders = nullptr;
+            for (auto& header: s_proxyHeaders) {
+                m_proxyHeaders = curl_slist_append(m_proxyHeaders, header.c_str());
+            }
+
+            if (!prepareForProxy(m_handle, m_proxyHeaders)) {
+                ACSDK_ERROR(LX("setDefaultOptions").d("reason", "prepareForProxy failed"));
+                break;
+            }
         }
 
-        if (!m_interfaceName.empty() && !setopt(CURLOPT_INTERFACE, m_interfaceName.c_str())) {
+        if (!s_interfaceName.empty() && !setopt(CURLOPT_INTERFACE, s_interfaceName.c_str())) {
             break;
         }
 
@@ -411,24 +428,24 @@ CURLcode CurlEasyHandleWrapper::pause(int mask) {
 }
 
 void CurlEasyHandleWrapper::setInterfaceName(const std::string& interfaceName) {
-    std::lock_guard<std::mutex> lock(m_interfaceNameMutex);
+    std::lock_guard<std::mutex> lock(s_settingsMutex);
     ACSDK_DEBUG(LX("setInterfaceName").d("interfaceName", interfaceName));
 
     if (interfaceName.empty()) {
-        m_interfaceName = interfaceName;
+        s_interfaceName = interfaceName;
         // Reset to default value from config, if provided.
         initializeNetworkInterfaceNameLocked();
         return;
     }
-    m_interfaceName = interfaceName;
+    s_interfaceName = interfaceName;
 }
 
 std::string CurlEasyHandleWrapper::getInterfaceName() {
-    std::lock_guard<std::mutex> lock(m_interfaceNameMutex);
-    if (!m_isInterfaceNameInitialized) {
+    std::lock_guard<std::mutex> lock(s_settingsMutex);
+    if (!s_isInterfaceNameInitialized) {
         initializeNetworkInterfaceNameLocked();
     }
-    return m_interfaceName;
+    return s_interfaceName;
 }
 
 void CurlEasyHandleWrapper::initializeNetworkInterfaceNameLocked() {
@@ -436,19 +453,34 @@ void CurlEasyHandleWrapper::initializeNetworkInterfaceNameLocked() {
     std::string interfaceNameFromConfig;
     config.getString(INTERFACE_CONFIG_KEY, &interfaceNameFromConfig, "");
 
-    if (m_interfaceName.empty() && !interfaceNameFromConfig.empty()) {
+    if (s_interfaceName.empty() && !interfaceNameFromConfig.empty()) {
         // Update the value from config, so that getInterfaceName always
         // return the current value.
-        m_interfaceName = interfaceNameFromConfig;
+        s_interfaceName = interfaceNameFromConfig;
     }
-    m_isInterfaceNameInitialized = true;
-    ACSDK_DEBUG(LX("initializeNetworkInterfaceName").d("m_interfaceName", m_interfaceName));
+    s_isInterfaceNameInitialized = true;
+    ACSDK_DEBUG(LX("initializeNetworkInterfaceNameLocked").d("s_interfaceName", s_interfaceName));
 }
 
 CurlEasyHandleWrapperOptionsSettingAdapter& CurlEasyHandleWrapper::curlOptionsSetter() {
     return m_curlOptionsSettingAdapter;
 }
 
+void CurlEasyHandleWrapper::setProxyHeaders(const std::vector<std::string>& headers) {
+    std::lock_guard<std::mutex> lock(s_settingsMutex);
+
+    std::ostringstream ss;
+    std::copy(headers.begin(), headers.end(), std::ostream_iterator<std::string>(ss, ";"));
+    ACSDK_DEBUG(LX("setProxyHeaders").d("headers", ss.str()));
+
+    s_proxyHeaders = headers;
+}
+
+std::vector<std::string> CurlEasyHandleWrapper::getProxyHeaders() {
+    std::lock_guard<std::mutex> lock(s_settingsMutex);
+    return s_proxyHeaders;
+}
+
 #ifdef ACSDK_EMIT_CURL_LOGS
 void CurlEasyHandleWrapper::initStreamLog() {
     std::string streamLogPrefix;
@@ -514,7 +546,7 @@ int CurlEasyHandleWrapper::debugFunction(CURL* handle, curl_infotype type, char*
         (*stream->m_streamLog) << logFormatter.format(
                                       logger::Level::INFO,
                                       std::chrono::system_clock::now(),
-                                      logger::ThreadMoniker::getThisThreadMoniker().c_str(),
+                                      logger::ThreadMoniker::getThisThreadMoniker(),
                                       curlInfoTypeToString(type))
                                << std::endl;
         if (CURLINFO_TEXT == type) {
diff --git a/AVSCommon/Utils/src/LibcurlUtils/HttpDelete.cpp b/AVSCommon/Utils/src/LibcurlUtils/HttpDelete.cpp
new file mode 100644
index 00000000..129fca85
--- /dev/null
+++ b/AVSCommon/Utils/src/LibcurlUtils/HttpDelete.cpp
@@ -0,0 +1,129 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <cstdlib>
+#include <cstring>
+#include <vector>
+
+#include <AVSCommon/Utils/LibcurlUtils/CallbackData.h>
+#include <AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h>
+#include <AVSCommon/Utils/LibcurlUtils/HttpDelete.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+using namespace alexaClientSDK::avsCommon::utils;
+
+/// String to identify log entries originating from this file.
+static const std::string TAG("HttpDelete");
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+/**
+ * Write callback function used for CURLOPT_WRITEFUNCTION option in libcurl
+ */
+static size_t writeCallback(char* dataBuffer, size_t blockSize, size_t numBlocks, void* dataStream);
+
+std::unique_ptr<HttpDelete> HttpDelete::create() {
+    std::unique_ptr<HttpDelete> httpDelete(new HttpDelete());
+    if (httpDelete->m_curl.isValid()) {
+        return httpDelete;
+    }
+    return nullptr;
+}
+
+HTTPResponse HttpDelete::doDelete(const std::string& url, const std::vector<std::string>& headers, std::chrono::seconds timeout ) {
+    std::lock_guard<std::mutex> lock(m_mutex);
+    const std::string errorEvent = "doDeleteFailed";
+    const std::string errorReasonKey = "reason";
+    HTTPResponse httpResponse;
+
+    if (!m_curl.reset()) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToResetCurlHandle"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setTransferTimeout(static_cast<long>(timeout.count()))) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetTimeout"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setURL(url)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetUrl"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setTransferType(CurlEasyHandleWrapper::TransferType::kDELETE)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetHttpRequestType"));
+        return httpResponse;
+    }
+
+    for (auto header : headers) {
+        if (!m_curl.addHTTPHeader(header)) {
+            ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToAddHttpHeader"));
+            return httpResponse;
+        }
+    }
+
+    CallbackData responseData;
+    if (!m_curl.setWriteCallback(writeCallback, &responseData)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetWriteCallback"));
+        return httpResponse;
+    }
+
+    CURLcode curlResult = m_curl.perform();
+    if (curlResult != CURLE_OK) {
+        ACSDK_ERROR(
+            LX(errorEvent).d(errorReasonKey, "curlFailedWithCode: " + std::string(curl_easy_strerror(curlResult))));
+        return httpResponse;
+    }
+
+    size_t responseSize = responseData.getSize();
+    if (responseSize > 0) {
+        std::vector<char> responseBody(responseSize + 1, 0);
+        responseData.getData(responseBody.data(), responseSize);
+        httpResponse.body = std::string(responseBody.data());
+    } else {
+        httpResponse.body = "";
+    }
+    httpResponse.code = m_curl.getHTTPResponseCode();
+
+    return httpResponse;
+}
+
+size_t writeCallback(char* dataBuffer, size_t blockSize, size_t numBlocks, void* dataStream) {
+    if (!dataStream) {
+        ACSDK_ERROR(LX("writeCallbackFailed").d("reason", "nullDataStream"));
+        return 0;
+    }
+
+    size_t realSize = blockSize * numBlocks;
+    CallbackData* callbackData = reinterpret_cast<CallbackData*>(dataStream);
+
+    return callbackData->appendData(dataBuffer, realSize);
+}
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp b/AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp
new file mode 100644
index 00000000..10e6836a
--- /dev/null
+++ b/AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp
@@ -0,0 +1,129 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <cstdlib>
+#include <cstring>
+#include <vector>
+
+#include <AVSCommon/Utils/LibcurlUtils/CallbackData.h>
+#include <AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h>
+#include <AVSCommon/Utils/LibcurlUtils/HttpGet.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+using namespace alexaClientSDK::avsCommon::utils;
+
+/// String to identify log entries originating from this file.
+static const std::string TAG("HttpGet");
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+/**
+ * Write callback function used for CURLOPT_WRITEFUNCTION option in libcurl
+ */
+static size_t writeCallback(char* dataBuffer, size_t blockSize, size_t numBlocks, void* dataStream);
+
+std::unique_ptr<HttpGet> HttpGet::create() {
+    std::unique_ptr<HttpGet> httpGet(new HttpGet());
+    if (httpGet->m_curl.isValid()) {
+        return httpGet;
+    }
+    return nullptr;
+}
+
+HTTPResponse HttpGet::doGet(const std::string& url, const std::vector<std::string>& headers, std::chrono::seconds timeout ) {
+    std::lock_guard<std::mutex> lock(m_mutex);
+    const std::string errorEvent = "doGetFailed";
+    const std::string errorReasonKey = "reason";
+    HTTPResponse httpResponse;
+
+    if (!m_curl.reset()) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToResetCurlHandle"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setTransferTimeout(static_cast<long>(timeout.count()))) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetTimeout"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setURL(url)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetUrl"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setTransferType(CurlEasyHandleWrapper::TransferType::kGET)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetHttpRequestType"));
+        return httpResponse;
+    }
+
+    for (auto header : headers) {
+        if (!m_curl.addHTTPHeader(header)) {
+            ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToAddHttpHeader"));
+            return httpResponse;
+        }
+    }
+
+    CallbackData responseData;
+    if (!m_curl.setWriteCallback(writeCallback, &responseData)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetWriteCallback"));
+        return httpResponse;
+    }
+
+    CURLcode curlResult = m_curl.perform();
+    if (curlResult != CURLE_OK) {
+        ACSDK_ERROR(
+            LX(errorEvent).d(errorReasonKey, "curlFailedWithCode: " + std::string(curl_easy_strerror(curlResult))));
+        return httpResponse;
+    }
+
+    size_t responseSize = responseData.getSize();
+    if (responseSize > 0) {
+        std::vector<char> responseBody(responseSize + 1, 0);
+        responseData.getData(responseBody.data(), responseSize);
+        httpResponse.body = std::string(responseBody.data());
+    } else {
+        httpResponse.body = "";
+    }
+    httpResponse.code = m_curl.getHTTPResponseCode();
+
+    return httpResponse;
+}
+
+size_t writeCallback(char* dataBuffer, size_t blockSize, size_t numBlocks, void* dataStream) {
+    if (!dataStream) {
+        ACSDK_ERROR(LX("writeCallbackFailed").d("reason", "nullDataStream"));
+        return 0;
+    }
+
+    size_t realSize = blockSize * numBlocks;
+    CallbackData* callbackData = reinterpret_cast<CallbackData*>(dataStream);
+
+    return callbackData->appendData(dataBuffer, realSize);
+}
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/src/LibcurlUtils/LibcurlUtils.cpp b/AVSCommon/Utils/src/LibcurlUtils/LibcurlUtils.cpp
index 3bedd403..ff2a3f64 100644
--- a/AVSCommon/Utils/src/LibcurlUtils/LibcurlUtils.cpp
+++ b/AVSCommon/Utils/src/LibcurlUtils/LibcurlUtils.cpp
@@ -131,7 +131,7 @@ bool prepareForTLS(CURL* handle) {
     return true;
 }
 
-bool prepareForProxy(CURL* handle) {
+bool prepareForProxy(CURL* handle, curl_slist* headers) {
     if (!handle) {
         ACSDK_ERROR(LX("prepareForProxyFailed").d("reason", "nullHandle"));
         return false;
@@ -140,10 +140,18 @@ bool prepareForProxy(CURL* handle) {
     auto config = configuration::ConfigurationNode::getRoot()[LIBCURLUTILS_CONFIG_KEY];
 
     std::string proxy;
-    if (config.getString(PROXY_CONFIG_KEY, &proxy) &&
-        !setopt(handle, CURLOPT_PROXY, proxy.c_str(), "CURLOPT_PROXY", proxy.c_str())) {
-        ACSDK_ERROR(LX("prepareForProxyFailed").d("reason", "CURLOPT_PROXY setopt Failed"));
-        return false;
+    if (config.getString(PROXY_CONFIG_KEY, &proxy)) {
+        if (!setopt(handle, CURLOPT_PROXY, proxy.c_str(), "CURLOPT_PROXY", proxy.c_str())) {
+            ACSDK_ERROR(LX("prepareForProxyFailed").d("reason", "CURLOPT_PROXY setopt Failed"));
+            return false;
+        }
+
+        if (headers) {
+            if (!setopt(handle, CURLOPT_PROXYHEADER, headers, "CURLOPT_PROXYHEADER", "...")) {
+                ACSDK_ERROR(LX("prepareForProxyFailed").d("reason", "CURLOPT_PROXYHEADER setopt Failed"));
+                return false;
+            }
+        }
     }
 
     return true;
diff --git a/AVSCommon/Utils/src/Logger/Logger.cpp b/AVSCommon/Utils/src/Logger/Logger.cpp
index 77097fd1..83e12b36 100644
--- a/AVSCommon/Utils/src/Logger/Logger.cpp
+++ b/AVSCommon/Utils/src/Logger/Logger.cpp
@@ -36,7 +36,7 @@ Logger::Logger(Level level) : m_level{level} {
 
 void Logger::log(Level level, const LogEntry& entry) {
     if (shouldLog(level)) {
-        emit(level, std::chrono::system_clock::now(), ThreadMoniker::getThisThreadMoniker().c_str(), entry.c_str());
+        emit(level, std::chrono::system_clock::now(), ThreadMoniker::getThisThreadMoniker(), entry.c_str());
     }
 }
 
diff --git a/AVSCommon/Utils/src/Logger/ThreadMoniker.cpp b/AVSCommon/Utils/src/Logger/ThreadMoniker.cpp
index 363ae08b..98e2ac93 100644
--- a/AVSCommon/Utils/src/Logger/ThreadMoniker.cpp
+++ b/AVSCommon/Utils/src/Logger/ThreadMoniker.cpp
@@ -14,6 +14,7 @@
  */
 
 #include <atomic>
+#include <cstring>
 #include <iomanip>
 #include <mutex>
 #include <sstream>
@@ -30,7 +31,9 @@ namespace logger {
 /// Counter to generate (small) unique thread monikers.
 static std::atomic<int> g_nextThreadMoniker(1);
 
-ThreadMoniker::ThreadMoniker(const std::string& moniker) : m_moniker{moniker.empty() ? generateMoniker() : moniker} {
+ThreadMoniker::ThreadMoniker(const std::string& moniker) : m_moniker{} {
+    auto& m = moniker.empty() ? generateMoniker() : moniker;
+    std::strncpy(m_moniker, m.c_str(), sizeof(m_moniker) - 1);
 }
 
 std::string ThreadMoniker::generateMoniker() {
diff --git a/CapabilitiesDelegate/include/CapabilitiesDelegate/CapabilitiesDelegate.h b/CapabilitiesDelegate/include/CapabilitiesDelegate/CapabilitiesDelegate.h
index 8a7106f8..a24d60ac 100644
--- a/CapabilitiesDelegate/include/CapabilitiesDelegate/CapabilitiesDelegate.h
+++ b/CapabilitiesDelegate/include/CapabilitiesDelegate/CapabilitiesDelegate.h
@@ -317,6 +317,9 @@ private:
     /// A struct containing the in-flight and pending endpoints for Discovery.addOrUpdateReport event.
     InProcessEndpointsToConfigMapStruct m_addOrUpdateEndpoints;
 
+    /// A list that preserves the endpointId order.
+    std::vector<std::string> m_endpointsOrderList;
+
     /// A struct containing the in-flight and pending endpoints Discovery.deleteReport event.
     InProcessEndpointsToConfigMapStruct m_deleteEndpoints;
 
diff --git a/CapabilitiesDelegate/include/CapabilitiesDelegate/DiscoveryEventSender.h b/CapabilitiesDelegate/include/CapabilitiesDelegate/DiscoveryEventSender.h
index d936567f..f878eec0 100644
--- a/CapabilitiesDelegate/include/CapabilitiesDelegate/DiscoveryEventSender.h
+++ b/CapabilitiesDelegate/include/CapabilitiesDelegate/DiscoveryEventSender.h
@@ -51,13 +51,16 @@ public:
      * @param authDelegate The auth delegate instance to request the auth token from to be sent in the @c Discovery
      * events.
      * @param waitForEventProcessed Indicate if sender should wait for the EventProcessed directive.
+     * @param endpointOrderList A list of endpointIds in registration order, used to preserve the order in @c Discovery
+     * events.
      * @return a new instance of the @c DiscoveryEventSender.
      */
     static std::shared_ptr<DiscoveryEventSender> create(
         const std::unordered_map<std::string, std::string>& addOrUpdateReportEndpoints,
         const std::unordered_map<std::string, std::string>& deleteReportEndpoints,
         const std::shared_ptr<avsCommon::sdkInterfaces::AuthDelegateInterface>& authDelegate,
-        const bool waitForEventProcessed = true);
+        const bool waitForEventProcessed = true,
+        const std::vector<std::string>& endpointOrderList = {});
 
     /**
      * Destructor.
@@ -92,12 +95,15 @@ private:
      * @param authDelegate The auth delegate instance to request the auth token from to be sent in the @c Discovery
      * events.
      * @param waitForEventProcessed Indicate if sender should wait for the EventProcessed directive.
+     * @param endpointOrderList A list of endpointIds in registration order, used to preserve the order in @c Discovery
+     * events.
      */
     DiscoveryEventSender(
         const std::unordered_map<std::string, std::string>& addOrUpdateReportEndpoints,
         const std::unordered_map<std::string, std::string>& deleteReportEndpoints,
         const std::shared_ptr<avsCommon::sdkInterfaces::AuthDelegateInterface>& authDelegate,
-        const bool waitForEventProcessed);
+        const bool waitForEventProcessed,
+        const std::vector<std::string>& endpointOrderList = {});
 
     /**
      * Sends the discovery event while taking into account retries.
@@ -193,6 +199,9 @@ private:
     /// Auth delegate used to get the access token
     std::shared_ptr<avsCommon::sdkInterfaces::AuthDelegateInterface> m_authDelegate;
 
+    /// The endpoint order list
+    std::vector<std::string> m_endpointsOrderList;
+
     /// The authDelegate's auth status.
     AuthObserverInterface::State m_currentAuthState;
 
diff --git a/CapabilitiesDelegate/src/CapabilitiesDelegate.cpp b/CapabilitiesDelegate/src/CapabilitiesDelegate.cpp
index 0e59286d..7178228c 100644
--- a/CapabilitiesDelegate/src/CapabilitiesDelegate.cpp
+++ b/CapabilitiesDelegate/src/CapabilitiesDelegate.cpp
@@ -303,6 +303,7 @@ bool CapabilitiesDelegate::addOrUpdateEndpoint(
         }
 
         m_addOrUpdateEndpoints.pending.insert(std::make_pair(endpointId, endpointConfigJson));
+        m_endpointsOrderList.push_back(endpointId);
     }
 
     if (!m_currentDiscoveryEventSender) {
@@ -466,6 +467,7 @@ std::shared_ptr<PostConnectOperationInterface> CapabilitiesDelegate::createPostC
     /// The endpoints that need to be sent to AVS.
     std::unordered_map<std::string, std::string> addOrUpdateEndpointsToSend;
     std::unordered_map<std::string, std::string> deleteEndpointsToSend;
+    std::vector<std::string> endpointOrderList;
     {
         std::lock_guard<std::mutex> lock{m_endpointsMutex};
 
@@ -513,6 +515,8 @@ std::shared_ptr<PostConnectOperationInterface> CapabilitiesDelegate::createPostC
         m_deleteEndpoints.inFlight = m_deleteEndpoints.pending;
         deleteEndpointsToSend = m_deleteEndpoints.inFlight;
         m_deleteEndpoints.pending.clear();
+
+        endpointOrderList = m_endpointsOrderList;
     }
 
     /// Sometimes pending add/update endpoints do not need to be sent to AVS as they are already stored
@@ -539,7 +543,7 @@ std::shared_ptr<PostConnectOperationInterface> CapabilitiesDelegate::createPostC
                      .d("num endpoints to delete", deleteEndpointsToSend.size()));
 
     std::shared_ptr<DiscoveryEventSenderInterface> newEventSender =
-        DiscoveryEventSender::create(addOrUpdateEndpointsToSend, deleteEndpointsToSend, m_authDelegate);
+        DiscoveryEventSender::create(addOrUpdateEndpointsToSend, deleteEndpointsToSend, m_authDelegate, true, endpointOrderList);
     if (!newEventSender) {
         ACSDK_ERROR(LX("createPostConnectOperationFailed").m("Could not create DiscoveryEventSender."));
         return nullptr;
diff --git a/CapabilitiesDelegate/src/DiscoveryEventSender.cpp b/CapabilitiesDelegate/src/DiscoveryEventSender.cpp
index 11106eae..254e3218 100644
--- a/CapabilitiesDelegate/src/DiscoveryEventSender.cpp
+++ b/CapabilitiesDelegate/src/DiscoveryEventSender.cpp
@@ -61,14 +61,15 @@ std::shared_ptr<DiscoveryEventSender> DiscoveryEventSender::create(
     const std::unordered_map<std::string, std::string>& addOrUpdateReportEndpoints,
     const std::unordered_map<std::string, std::string>& deleteReportEndpoints,
     const std::shared_ptr<AuthDelegateInterface>& authDelegate,
-    const bool waitForEventProcessed) {
+    const bool waitForEventProcessed,
+    const std::vector<std::string>& endpointOrderList) {
     if (addOrUpdateReportEndpoints.empty() && deleteReportEndpoints.empty()) {
         ACSDK_ERROR(LX("createFailed").d("reason", "endpoint map empty"));
     } else if (!authDelegate) {
         ACSDK_ERROR(LX("createFailed").d("reason", "invalid auth delegate"));
     } else {
         auto instance = std::shared_ptr<DiscoveryEventSender>(new DiscoveryEventSender(
-            addOrUpdateReportEndpoints, deleteReportEndpoints, authDelegate, waitForEventProcessed));
+            addOrUpdateReportEndpoints, deleteReportEndpoints, authDelegate, waitForEventProcessed, endpointOrderList));
 
         return instance;
     }
@@ -79,10 +80,12 @@ DiscoveryEventSender::DiscoveryEventSender(
     const std::unordered_map<std::string, std::string>& addOrUpdateReportEndpoints,
     const std::unordered_map<std::string, std::string>& deleteReportEndpoints,
     const std::shared_ptr<AuthDelegateInterface>& authDelegate,
-    const bool waitForEventProcessed) :
+    const bool waitForEventProcessed,
+    const std::vector<std::string>& endpointOrderList) :
         m_addOrUpdateReportEndpoints{addOrUpdateReportEndpoints},
         m_deleteReportEndpoints{deleteReportEndpoints},
         m_authDelegate{authDelegate},
+        m_endpointsOrderList{endpointOrderList},
         m_currentAuthState{AuthObserverInterface::State::UNINITIALIZED},
         m_isStopping{false},
         m_isSendDiscoveryEventsInvoked{false},
@@ -317,8 +320,17 @@ bool DiscoveryEventSender::sendAddOrUpdateReportEvents(
     }
     /// Collect all endpoint configurations
     std::vector<std::string> allEndpointConfigs;
-    for (const auto& endpointIdToConfigPair : m_addOrUpdateReportEndpoints) {
-        allEndpointConfigs.push_back(endpointIdToConfigPair.second);
+    if (!m_endpointsOrderList.empty()) {
+        /// Look into the endpoints map in the order of the m_endpointsOrderList
+        for (const auto& endpointId : m_endpointsOrderList) {
+            if (m_addOrUpdateReportEndpoints.find(endpointId) != m_addOrUpdateReportEndpoints.end()) {
+                allEndpointConfigs.push_back(m_addOrUpdateReportEndpoints[endpointId]);
+            }
+        }
+    } else {
+        for (const auto& endpointIdToConfigPair : m_addOrUpdateReportEndpoints) {
+            allEndpointConfigs.push_back(endpointIdToConfigPair.second);
+        }
     }
 
     return sendDiscoveryEvents(allEndpointConfigs, messageSender, true);
diff --git a/CapabilitiesDelegate/src/Utils/DiscoveryUtils.cpp b/CapabilitiesDelegate/src/Utils/DiscoveryUtils.cpp
index 62c7dcdb..f07127ac 100644
--- a/CapabilitiesDelegate/src/Utils/DiscoveryUtils.cpp
+++ b/CapabilitiesDelegate/src/Utils/DiscoveryUtils.cpp
@@ -68,6 +68,8 @@ const static std::string FRIENDLY_NAME_KEY = "friendlyName";
 const static std::string DESCRIPTION_KEY = "description";
 /// Manufacturer name key
 const static std::string MANUFACTURER_NAME_KEY = "manufacturerName";
+/// EndpointResources ID key
+const static std::string ENDPOINTRESOURCES_KEY = "endpointResources";
 /// Display Categories key
 const static std::string DISPLAY_CATEGORIES_KEY = "displayCategories";
 /// Additional Attributes key
@@ -259,14 +261,18 @@ bool validateEndpointAttributes(const AVSDiscoveryEndpointAttributes& endpointAt
         return false;
     }
 
-    if (!endpoints::isDescriptionValid(endpointAttributes.description)) {
-        ACSDK_ERROR(LX("validateEndpointAttributesFailed").d("reason", "invalidDescription"));
-        return false;
-    }
+    if (!endpoints::isEndpointResourcesValid(endpointAttributes.endpointResources)) {
 
-    if (!endpoints::isManufacturerNameValid(endpointAttributes.manufacturerName)) {
-        ACSDK_ERROR(LX("validateEndpointAttributesFailed").d("reason", "invalidManufacturerName"));
-        return false;
+    // Validate the legacy fields if the endpointResources object is invalid.
+        if (!endpoints::isDescriptionValid(endpointAttributes.description)) {
+            ACSDK_ERROR(LX("validateEndpointAttributesFailed").d("reason", "invalidDescription"));
+            return false;
+        }
+
+        if (!endpoints::isManufacturerNameValid(endpointAttributes.manufacturerName)) {
+            ACSDK_ERROR(LX("validateEndpointAttributesFailed").d("reason", "invalidManufacturerName"));
+            return false;
+        }
     }
 
     if (endpointAttributes.displayCategories.empty()) {
@@ -299,9 +305,14 @@ std::string getEndpointConfigJson(
     JsonGenerator generator;
 
     generator.addMember(ENDPOINT_ID_KEY, endpointAttributes.endpointId);
-    generator.addMember(FRIENDLY_NAME_KEY, endpointAttributes.friendlyName);
-    generator.addMember(DESCRIPTION_KEY, endpointAttributes.description);
-    generator.addMember(MANUFACTURER_NAME_KEY, endpointAttributes.manufacturerName);
+    /// Endpoint Resources.
+    if (endpointAttributes.endpointResources.isValid()) {
+        generator.addRawJsonMember(ENDPOINTRESOURCES_KEY, endpointAttributes.endpointResources.build());
+    } else {
+        generator.addMember(FRIENDLY_NAME_KEY, endpointAttributes.friendlyName);
+        generator.addMember(DESCRIPTION_KEY, endpointAttributes.description);
+        generator.addMember(MANUFACTURER_NAME_KEY, endpointAttributes.manufacturerName);
+    }
     addSortedStringArray(generator, DISPLAY_CATEGORIES_KEY, endpointAttributes.displayCategories);
 
     /// Additional Attributes Object.
diff --git a/CapabilityAgents/CMakeLists.txt b/CapabilityAgents/CMakeLists.txt
index e673ee26..d77d0f05 100644
--- a/CapabilityAgents/CMakeLists.txt
+++ b/CapabilityAgents/CMakeLists.txt
@@ -9,6 +9,7 @@ set(CAPABILITY_AGENTS
         "ApiGateway"
         "Equalizer"
         "InteractionModel"
+        "Messaging"
         "Notifications"
         "PlaybackController"
         "SoftwareComponentReporter"
diff --git a/CapabilityAgents/InteractionModel/acsdkInteractionModel/include/acsdkInteractionModel/InteractionModelFactory.h b/CapabilityAgents/InteractionModel/acsdkInteractionModel/include/acsdkInteractionModel/InteractionModelFactory.h
new file mode 100644
index 00000000..5c2ec7c0
--- /dev/null
+++ b/CapabilityAgents/InteractionModel/acsdkInteractionModel/include/acsdkInteractionModel/InteractionModelFactory.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_CAPABILITYAGENTS_INTERACTIONMODEL_ACSDKINTERACTIONMODEL_INCLUDE_ACSDKINTERACTIONMODEL_INTERACTIONMODELFACTORY_H_
+#define ALEXA_CLIENT_SDK_CAPABILITYAGENTS_INTERACTIONMODEL_ACSDKINTERACTIONMODEL_INCLUDE_ACSDKINTERACTIONMODEL_INTERACTIONMODELFACTORY_H_
+
+#include <memory>
+
+#include <acsdkInteractionModelInterfaces/InteractionModelNotifierInterface.h>
+#include <AVSCommon/SDKInterfaces/CapabilityConfigurationInterface.h>
+#include <AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h>
+#include <AVSCommon/SDKInterfaces/ExceptionEncounteredSenderInterface.h>
+#include <AVSCommon/Utils/Optional.h>
+
+namespace alexaClientSDK {
+namespace acsdkInteractionModel {
+
+/// This structure contains the interfaces to interact with the InputController Capability Agent.
+struct InteractionModelFactoryInterfaces {
+    /// Interface for handling @c AVSDirectives.
+    std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::DirectiveHandlerInterface> directiveHandler;
+
+    /// Interface providing CapabilitiesDelegate access to the version and configurations of the capabilities.
+    std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::CapabilityConfigurationInterface>
+        capabilityConfigurationInterface;
+
+    /// Interface for Notifier.
+    std::shared_ptr<acsdkInteractionModelInterfaces::InteractionModelNotifierInterface> notifier;
+};
+
+/**
+ * Creates a new InteractionModel Capability Agent
+ *
+ * @param directiveSequencer The Directive Sequencer responsible for processing AVS directives.
+ * @param exceptionEncounteredSender The object to use for sending AVS Exception messages.
+ * @return An @c Optional @c InputControllerFactoryInterfaces object.
+ */
+avsCommon::utils::Optional<InteractionModelFactoryInterfaces> createInteractionModelCA(
+    const std::shared_ptr<avsCommon::sdkInterfaces::DirectiveSequencerInterface>& directiveSequencer,
+    const std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface>& exceptionEncounteredSender);
+
+}  // namespace acsdkInteractionModel
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_CAPABILITYAGENTS_INTERACTIONMODEL_ACSDKINTERACTIONMODEL_INCLUDE_ACSDKINTERACTIONMODEL_INTERACTIONMODELFACTORY_H_
diff --git a/CapabilityAgents/InteractionModel/acsdkInteractionModel/privateInclude/acsdkInteractionModel/InteractionModelCapabilityAgent.h b/CapabilityAgents/InteractionModel/acsdkInteractionModel/privateInclude/acsdkInteractionModel/InteractionModelCapabilityAgent.h
index 3e32fbea..f5fe0fa2 100644
--- a/CapabilityAgents/InteractionModel/acsdkInteractionModel/privateInclude/acsdkInteractionModel/InteractionModelCapabilityAgent.h
+++ b/CapabilityAgents/InteractionModel/acsdkInteractionModel/privateInclude/acsdkInteractionModel/InteractionModelCapabilityAgent.h
@@ -54,6 +54,20 @@ public:
      * @param exceptionEncounteredSender The object to use for sending AVS Exception messages.
      * @param interactionModelNotifier The object to notify of RequestProcessing events, which relays the message
      * to registered observers.
+     */
+    static std::shared_ptr<InteractionModelCapabilityAgent> createLegacy(
+        std::shared_ptr<avsCommon::sdkInterfaces::DirectiveSequencerInterface> directiveSequencer,
+        std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionEncounteredSender,
+        std::shared_ptr<acsdkInteractionModelInterfaces::InteractionModelNotifierInterface> interactionModelNotifier);
+
+    /**
+     * Creates an instance of the Interaction Model capability agent.  Using the endpointCapabilitiesRegistrar to self
+     * register.
+     *
+     * @param directiveSequencer The Directive Sequencer responsible for processing AVS directives.
+     * @param exceptionEncounteredSender The object to use for sending AVS Exception messages.
+     * @param interactionModelNotifier The object to notify of RequestProcessing events, which relays the message
+     * to registered observers.
      * @param endpointCapabilitiesRegistrar The object with which to register this CA's capabilities for the default
      * endpoint.
      */
diff --git a/CapabilityAgents/InteractionModel/acsdkInteractionModel/src/CMakeLists.txt b/CapabilityAgents/InteractionModel/acsdkInteractionModel/src/CMakeLists.txt
index 27f2876a..46637d7c 100644
--- a/CapabilityAgents/InteractionModel/acsdkInteractionModel/src/CMakeLists.txt
+++ b/CapabilityAgents/InteractionModel/acsdkInteractionModel/src/CMakeLists.txt
@@ -3,6 +3,7 @@ add_definitions("-DACSDK_LOG_MODULE=interactionModel")
 add_library(acsdkInteractionModel SHARED
         InteractionModelCapabilityAgent.cpp
         InteractionModelComponent.cpp
+        InteractionModelFactory.cpp
         InteractionModelNotifier.cpp)
 
 target_include_directories(acsdkInteractionModel PRIVATE
diff --git a/CapabilityAgents/InteractionModel/acsdkInteractionModel/src/InteractionModelCapabilityAgent.cpp b/CapabilityAgents/InteractionModel/acsdkInteractionModel/src/InteractionModelCapabilityAgent.cpp
index 236d9e2d..f3d00604 100644
--- a/CapabilityAgents/InteractionModel/acsdkInteractionModel/src/InteractionModelCapabilityAgent.cpp
+++ b/CapabilityAgents/InteractionModel/acsdkInteractionModel/src/InteractionModelCapabilityAgent.cpp
@@ -82,34 +82,46 @@ static std::shared_ptr<CapabilityConfiguration> getInteractionModelCapabilityCon
     return std::make_shared<CapabilityConfiguration>(configMap);
 }
 
-std::shared_ptr<InteractionModelCapabilityAgent> InteractionModelCapabilityAgent::create(
+std::shared_ptr<InteractionModelCapabilityAgent> InteractionModelCapabilityAgent::createLegacy(
     std::shared_ptr<DirectiveSequencerInterface> directiveSequencer,
     std::shared_ptr<ExceptionEncounteredSenderInterface> exceptionEncounteredSender,
-    std::shared_ptr<InteractionModelNotifierInterface> interactionModelNotifier,
-    acsdkManufactory::Annotated<
-        avsCommon::sdkInterfaces::endpoints::DefaultEndpointAnnotation,
-        avsCommon::sdkInterfaces::endpoints::EndpointCapabilitiesRegistrarInterface> endpointCapabilitiesRegistrar) {
+    std::shared_ptr<InteractionModelNotifierInterface> interactionModelNotifier) {
     if (!directiveSequencer) {
-        ACSDK_ERROR(LX("createFailed").d("reason", "nullDirectiveSequencer"));
+        ACSDK_ERROR(LX("createLegacyFailed").d("reason", "nullDirectiveSequencer"));
         return nullptr;
     }
     if (!exceptionEncounteredSender) {
-        ACSDK_ERROR(LX("createFailed").d("reason", "nullExceptionEncounteredSender"));
+        ACSDK_ERROR(LX("createLegacyFailed").d("reason", "nullExceptionEncounteredSender"));
         return nullptr;
     }
     if (!interactionModelNotifier) {
-        ACSDK_ERROR(LX("createFailed").d("reason", "nullInteractionModelNotifier"));
+        ACSDK_ERROR(LX("createLegacyFailed").d("reason", "nullInteractionModelNotifier"));
         return nullptr;
     }
+
+    auto interactionModelCapabilityAgent = std::shared_ptr<InteractionModelCapabilityAgent>(
+        new InteractionModelCapabilityAgent(directiveSequencer, exceptionEncounteredSender, interactionModelNotifier));
+
+    return interactionModelCapabilityAgent;
+}
+
+std::shared_ptr<InteractionModelCapabilityAgent> InteractionModelCapabilityAgent::create(
+    std::shared_ptr<DirectiveSequencerInterface> directiveSequencer,
+    std::shared_ptr<ExceptionEncounteredSenderInterface> exceptionEncounteredSender,
+    std::shared_ptr<InteractionModelNotifierInterface> interactionModelNotifier,
+    acsdkManufactory::Annotated<
+        avsCommon::sdkInterfaces::endpoints::DefaultEndpointAnnotation,
+        avsCommon::sdkInterfaces::endpoints::EndpointCapabilitiesRegistrarInterface> endpointCapabilitiesRegistrar) {
     if (!endpointCapabilitiesRegistrar) {
         ACSDK_ERROR(LX("createFailed").d("reason", "nullEndpointCapabilitiesRegistrar"));
         return nullptr;
     }
 
-    auto interactionModelCapabilityAgent = std::shared_ptr<InteractionModelCapabilityAgent>(
-        new InteractionModelCapabilityAgent(directiveSequencer, exceptionEncounteredSender, interactionModelNotifier));
-
-    endpointCapabilitiesRegistrar->withCapability(interactionModelCapabilityAgent, interactionModelCapabilityAgent);
+    auto interactionModelCapabilityAgent =
+        createLegacy(directiveSequencer, exceptionEncounteredSender, interactionModelNotifier);
+    if (interactionModelCapabilityAgent) {
+        endpointCapabilitiesRegistrar->withCapability(interactionModelCapabilityAgent, interactionModelCapabilityAgent);
+    }
 
     return interactionModelCapabilityAgent;
 }
diff --git a/CapabilityAgents/InteractionModel/acsdkInteractionModel/src/InteractionModelFactory.cpp b/CapabilityAgents/InteractionModel/acsdkInteractionModel/src/InteractionModelFactory.cpp
new file mode 100644
index 00000000..a4362997
--- /dev/null
+++ b/CapabilityAgents/InteractionModel/acsdkInteractionModel/src/InteractionModelFactory.cpp
@@ -0,0 +1,47 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include "acsdkInteractionModel/InteractionModelCapabilityAgent.h"
+#include "acsdkInteractionModel/InteractionModelFactory.h"
+#include "acsdkInteractionModel/InteractionModelNotifier.h"
+
+namespace alexaClientSDK {
+namespace acsdkInteractionModel {
+
+using namespace avsCommon::utils;
+
+Optional<InteractionModelFactoryInterfaces> createInteractionModelCA(
+    const std::shared_ptr<avsCommon::sdkInterfaces::DirectiveSequencerInterface>& directiveSequencer,
+    const std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface>& exceptionEncounteredSender) {
+    auto notifier = InteractionModelNotifier::createInteractionModelNotifierInterface();
+    if (!notifier) {
+        return Optional<InteractionModelFactoryInterfaces>();
+    }
+
+    auto interactionModelCA =
+        InteractionModelCapabilityAgent::createLegacy(directiveSequencer, exceptionEncounteredSender, notifier);
+    if (!interactionModelCA) {
+        return Optional<InteractionModelFactoryInterfaces>();
+    }
+
+    InteractionModelFactoryInterfaces interfaces;
+    interfaces.notifier = notifier;
+    interfaces.capabilityConfigurationInterface = interactionModelCA;
+    interfaces.directiveHandler = interactionModelCA;
+    return Optional<InteractionModelFactoryInterfaces>(interfaces);
+}
+
+}  // namespace acsdkInteractionModel
+}  // namespace alexaClientSDK
\ No newline at end of file
diff --git a/CapabilityAgents/Messaging/CMakeLists.txt b/CapabilityAgents/Messaging/CMakeLists.txt
new file mode 100644
index 00000000..3450990e
--- /dev/null
+++ b/CapabilityAgents/Messaging/CMakeLists.txt
@@ -0,0 +1,5 @@
+cmake_minimum_required(VERSION 3.0)
+project(Messaging LANGUAGES CXX)
+
+add_subdirectory("src")
+add_subdirectory("test")
diff --git a/CapabilityAgents/Messaging/include/Messaging/MessagingCapabilityAgent.h b/CapabilityAgents/Messaging/include/Messaging/MessagingCapabilityAgent.h
new file mode 100644
index 00000000..56d420a9
--- /dev/null
+++ b/CapabilityAgents/Messaging/include/Messaging/MessagingCapabilityAgent.h
@@ -0,0 +1,513 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_CAPABILITYAGENTS_MESSAGING_INCLUDE_MESSAGING_MESSAGINGCAPABILITYAGENT_H_
+#define ALEXA_CLIENT_SDK_CAPABILITYAGENTS_MESSAGING_INCLUDE_MESSAGING_MESSAGINGCAPABILITYAGENT_H_
+
+#include <memory>
+#include <unordered_set>
+#include <unordered_map>
+
+#include <AVSCommon/AVS/CapabilityAgent.h>
+#include <AVSCommon/AVS/CapabilityConfiguration.h>
+#include <AVSCommon/SDKInterfaces/CapabilityConfigurationInterface.h>
+#include <AVSCommon/SDKInterfaces/ContextManagerInterface.h>
+#include <AVSCommon/SDKInterfaces/ExceptionEncounteredSenderInterface.h>
+#include <AVSCommon/SDKInterfaces/MessageSenderInterface.h>
+#include <AVSCommon/SDKInterfaces/Messaging/MessagingObserverInterface.h>
+#include <AVSCommon/SDKInterfaces/StateProviderInterface.h>
+#include <AVSCommon/Utils/RequiresShutdown.h>
+#include <AVSCommon/Utils/Threading/Executor.h>
+#include <AVSCommon/Utils/UUIDGeneration/UUIDGeneration.h>
+
+namespace alexaClientSDK {
+namespace capabilityAgents {
+namespace messaging {
+
+/**
+ * This class implements the @c MessagingController capability agent.
+ *
+ * @see https://developer.amazon.com/docs/alexa-voice-service/
+ *
+ * @note For instances of this class to be cleaned up correctly, @c shutdown() must be called.
+ * @note This class makes use of a global configuration to a database file, meaning that it is best used
+ * as a singleton.
+ */
+class MessagingCapabilityAgent
+        : public avsCommon::avs::CapabilityAgent
+        , public avsCommon::sdkInterfaces::CapabilityConfigurationInterface
+        , public avsCommon::utils::RequiresShutdown
+        , public std::enable_shared_from_this<MessagingCapabilityAgent> {
+public:
+    /**
+     * Messaging endpoint reference.
+     */
+    using MessagingEndpoint = avsCommon::sdkInterfaces::messaging::MessagingObserverInterface::MessagingEndpoint;
+
+    /**
+     * An enum representing the status error codes.
+     */
+    enum class StatusErrorCode {
+        /// Generic failure occurred during request processing.
+        GENERIC_FAILURE,
+
+        /// No connection was found during request processing.
+        NO_CONNECTIVITY,
+
+        /// Messaging endpoint does not have needed permissions.
+        NO_PERMISSION
+    };
+
+    /**
+     * An enum representing the @c UploadMode.
+     */
+    enum class UploadMode {
+        /// Existing messages should be deleted and replaced with uploaded ones.
+        DELETE_ALL_AND_STORE
+    };
+
+    /**
+     * An enum representing the @c ConnectionState.
+     */
+    enum class ConnectionState {
+        /// Messaging endpoint is disconnected.
+        DISCONNECTED,
+
+        /// Messaging endpoint is connected.
+        CONNECTED
+    };
+
+    /**
+     * An enum representing the @c Permission for @sa ConversationsReport.
+     */
+    enum class PermissionState {
+        /// Permission is turned off.
+        OFF,
+
+        /// Permission is turned on.
+        ON
+    };
+
+    /*
+     *  Defines a container for the messaging endpoint state.
+     */
+    struct MessagingEndpointState {
+        /*
+         * Constructor. Initializes the configuration to default.
+         */
+        MessagingEndpointState() :
+                connection{ConnectionState::DISCONNECTED},
+                sendPermission{PermissionState::OFF},
+                readPermission{PermissionState::OFF} {};
+
+        /**
+         * Constructor for initializing with specified states.
+         * @param connectionIn The state of the connection.
+         * @param sendPermission The state of the send permission.
+         * @param readPermission The state of the read permission.
+         */
+        MessagingEndpointState(
+            ConnectionState connectionIn,
+            PermissionState sendPermissionIn,
+            PermissionState readPermissionIn) :
+                connection{connectionIn}, sendPermission{sendPermissionIn}, readPermission{readPermissionIn} {
+        }
+
+        /// Connection state
+        ConnectionState connection;
+
+        /// Send permission state.
+        PermissionState sendPermission;
+
+        /// Read permission state.
+        PermissionState readPermission;
+    };
+
+    /**
+     * Destructor.
+     */
+    virtual ~MessagingCapabilityAgent() = default;
+
+    /**
+     * Factory method to create a @c MessagingCapabilityAgent instance.
+     *
+     * @param exceptionSender Interface to report exceptions to AVS.
+     * @param contextManager Interface to provide messaging state to AVS.
+     * @param messageSender Interface to send events to AVS.
+     * @return A new instance of @c MessagingCapabilityAgent on success, @c nullptr otherwise.
+     */
+    static std::shared_ptr<MessagingCapabilityAgent> create(
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::MessageSenderInterface> messageSender);
+
+    /// @name CapabilityAgent Functions
+    /// @{
+    alexaClientSDK::avsCommon::avs::DirectiveHandlerConfiguration getConfiguration() const override;
+    void handleDirectiveImmediately(std::shared_ptr<alexaClientSDK::avsCommon::avs::AVSDirective> directive) override;
+    void preHandleDirective(
+        std::shared_ptr<alexaClientSDK::avsCommon::avs::CapabilityAgent::DirectiveInfo> info) override;
+    void handleDirective(std::shared_ptr<alexaClientSDK::avsCommon::avs::CapabilityAgent::DirectiveInfo> info) override;
+    void cancelDirective(std::shared_ptr<alexaClientSDK::avsCommon::avs::CapabilityAgent::DirectiveInfo> info) override;
+    /// @}
+
+    /// @name CapabilityConfigurationInterface method
+    /// @{
+    std::unordered_set<std::shared_ptr<avsCommon::avs::CapabilityConfiguration>> getCapabilityConfigurations() override;
+    /// @}
+
+    /// @name RequiresShutdown method
+    /// @{
+    void doShutdown() override;
+    /// @}
+
+    /// @name StateProviderInterface Functions
+    /// @{
+    void provideState(
+        const avsCommon::avs::CapabilityTag& stateProviderName,
+        const avsCommon::sdkInterfaces::ContextRequestToken contextRequestToken) override;
+    /// @}
+
+    /**
+     * Adds an observer to @c MessagingCapabilityAgent so that it will get notified for all
+     * messaging related directives.
+     *
+     * @param observer The @c MessagingObserverInterface to add.
+     */
+    void addObserver(std::shared_ptr<avsCommon::sdkInterfaces::messaging::MessagingObserverInterface> observer);
+
+    /**
+     * Removes an observer from @c MessagingCapabilityAgent so that it will no longer be
+     * notified of messaging related directives.
+     *
+     * @param observer The @c MessagingObserverInterface
+     */
+    void removeObserver(std::shared_ptr<avsCommon::sdkInterfaces::messaging::MessagingObserverInterface> observer);
+
+    /**
+     * Sends an event to notify AVS of new messages available on the device.
+     *
+     * @note This method should be called when the device is connected.
+     * @note If this is called in response to an @c UploadConversations directive, then the token
+     * received in @c UploadConversations should be passed back. Otherwise, an empty string should be sent.
+     *
+     * @param The token received from @c uploadConversations, otherwise an empty string.
+     * @param conversations A JSON array representing the unread messages of the messaging endpoint.
+     * @code{.json}
+     * [
+     *     {
+     *         "id": "{{STRING}}",
+     *         "otherParticipants": [
+     *             {
+     *                 "address":"{{STRING}}",
+     *                 "addressType":"PhoneNumberAddress"
+     *             }
+     *         ],
+     *         "messages": [
+     *             {
+     *                 "id":"{{STRING}}",
+     *                 "payload": {
+     *                     "@type":"text",
+     *                     "text":"{{STRING}}"
+     *                 },
+     *                 "status":"unread",
+     *                 "createdTime":"{{STRING}}",
+     *                 "sender": {
+     *                     "address":"{{STRING}}",
+     *                     "addressType":"PhoneNumberAddress"
+     *                 }
+     *             }
+     *         ],
+     *         "unreadMessageCount":1
+     *     }
+     * ]
+     * @endcode
+     * @li id A unique identifier generated by the application for the conversation.
+     * @li otherParticipants Optional recipients if messages are part of a group conversation, otherwise empty JSON
+     * array.
+     * @li otherParticipants.address The phone number of the recipient.
+     * @li otherParticipants.addressType Hard coded string "PhoneNumberAddress" indicating the value of the @c address
+     * field.
+     * @li messages.id A unique identifier generated by the application for the message.
+     * @li messages.payload.@type Hard coded string "text" indicating the value of the @c text field.
+     * @li messages.text The text for the message.
+     * @li messages.createdTime (optional) The ISO 8601 timestamp of when the message was created on the device.
+     * @li messages.sender.address The phone number of the sender.
+     * @li messages.sender.addressType Hard coded string "PhoneNumberAddress" indicating the value of the @c address
+     * field.
+     * @li unreadMessageCount The total number of unread messages in this conversation..
+     */
+    void conversationsReport(
+        const std::string& token,
+        const std::string& conversations,
+        UploadMode mode = UploadMode::DELETE_ALL_AND_STORE,
+        MessagingEndpoint messagingEndpoint = MessagingEndpoint::DEFAULT);
+
+    /**
+     * Sends an event to notify AVS that the message was sent successfully.
+     *
+     * @param token The token corresponding to the @c MessagingObserverInterface::sendMessage request.
+     * @param messagingEndpoint The messaging endpoint that sent the message successfully.
+     */
+    void sendMessageSucceeded(
+        const std::string& token,
+        MessagingEndpoint messagingEndpoint = MessagingEndpoint::DEFAULT);
+
+    /**
+     * Sends an event to notify AVS that the message failed to be sent.
+     *
+     * @param token The token corresponding to the @c MessagingObserverInterface::sendMessage request.
+     * @param code The @c StatusErrorCode describing why the request failed.
+     * @param message The reason for the failure or empty string.
+     * @param messagingEndpoint The messaging endpoint that failed to send the message.
+     */
+    void sendMessageFailed(
+        const std::string& token,
+        StatusErrorCode code,
+        const std::string& message,
+        MessagingEndpoint messagingEndpoint = MessagingEndpoint::DEFAULT);
+
+    /**
+     * Sends an event to notify AVS that the message status request was successful.
+     *
+     * @param token The token corresponding to the @c MessagingObserverInterface::updateMessagesStatus request.
+     * @param messagingEndpoint The messaging endpoint that update status successfully.
+     */
+    void updateMessagesStatusSucceeded(
+        const std::string& token,
+        MessagingEndpoint messagingEndpoint = MessagingEndpoint::DEFAULT);
+
+    /**
+     * Sends an event to notify AVS that the message status request failed.
+     *
+     * @param token The token corresponding to the @c MessagingObserverInterface::sendMessage request.
+     * @param code The @c StatusErrorCode describing why the request failed.
+     * @param message The reason for the failure or empty string.
+     * @param messagingEndpoint The messaging endpoint that failed to update status.
+     */
+    void updateMessagesStatusFailed(
+        const std::string& token,
+        StatusErrorCode code,
+        const std::string& message,
+        MessagingEndpoint messagingEndpoint = MessagingEndpoint::DEFAULT);
+
+    /**
+     * This function updates the @c MessagingCapabilityAgent context.
+     *
+     * @param messagingEndpointState The current state of the messaging endpoint.
+     * @param messagingEndpoint The messaging endpoint whose state will be updated.
+     */
+    void updateMessagingEndpointState(
+        MessagingEndpointState messagingEndpointState,
+        MessagingEndpoint messagingEndpoint = MessagingEndpoint::DEFAULT);
+
+private:
+    /**
+     * Constructor.
+     *
+     * @param exceptionSender Interface to report exceptions to AVS.
+     * @param contextManager Interface to provide state to AVS.
+     * @param messageSender Interface to send events to AVS
+     */
+    MessagingCapabilityAgent(
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::MessageSenderInterface> messageSender);
+
+    /**
+     * Initializes the object.
+     */
+    bool initialize();
+
+    /**
+     * Prepares MessagingController Interface DCF configuration and keeps it internally.
+     */
+    void generateCapabilityConfiguration();
+
+    /**
+     * Builds JSON string for the device capabilities reported.
+     */
+    std::string buildMessagingEndpointConfigurationJson();
+
+    /**
+     * Remove a directive from the map of message IDs to DirectiveInfo instances.
+     *
+     * @param info The @c DirectiveInfo containing the @c AVSDirective whose message ID is to be removed.
+     */
+    void removeDirective(std::shared_ptr<DirectiveInfo> info);
+
+    /**
+     * Marks the directive as completed.
+     *
+     * @param info The directive currently being handled.
+     */
+    void executeSetHandlingCompleted(std::shared_ptr<DirectiveInfo> info);
+
+    /**
+     * Handles the @c SendMessage AVS Directive.
+     *
+     * @param info The @c DirectiveInfo containing the @c AVSDirective and the @c DirectiveHandlerResultInterface.
+     * @param payload A @c rapidjson::Document holding the parsed directive payload.
+     * @return @c true if operation succeeds and could be reported as such to AVS, @c false if an error occurred. False
+     * implies that exception has been reported to AVS and directive is already processed.
+     */
+    bool executeSendMessageDirective(std::shared_ptr<DirectiveInfo> info, rapidjson::Document& payload);
+
+    /**
+     * Handles the @c UpdateMessagesStatus AVS Directive.
+     *
+     * @param info The @c DirectiveInfo containing the @c AVSDirective and the @c DirectiveHandlerResultInterface.
+     * @param payload A @c rapidjson::Document holding the parsed directive payload.
+     * @return @c true if operation succeeds and could be reported as such to AVS, @c false if an error occurred. False
+     * implies that exception has been reported to AVS and directive is already processed.
+     */
+    bool executeUpdateMessagesStatusDirective(std::shared_ptr<DirectiveInfo> info, rapidjson::Document& payload);
+
+    /**
+     * Handles the @c UploadConversations AVS Directive.
+     *
+     * @param info The @c DirectiveInfo containing the @c AVSDirective and the @c DirectiveHandlerResultInterface.
+     * @param payload A @c rapidjson::Document holding the parsed directive payload*
+     */
+    bool executeUploadConversationsDirective(std::shared_ptr<DirectiveInfo> info, rapidjson::Document& payload);
+
+    /**
+     * This function updates the context for the @c MessagingCapabilityAgent.
+     */
+    void executeUpdateMessagingEndpointContext();
+
+    /**
+     * Gets the current state of the messaging endpoint and notifies @c ContextManager
+     *
+     * @param stateProviderName Provides the property name and used in the @c ContextManager methods.
+     * @param contextRequestToken The token to be used when providing the response to @c ContextManager
+     */
+    void executeProvideState(
+        const avsCommon::avs::CapabilityTag& stateProviderName,
+        const avsCommon::sdkInterfaces::ContextRequestToken contextRequestToken);
+
+    /// The ContextManager object.
+    std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> m_contextManager;
+
+    /// The regular MessageSender object.
+    std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> m_messageSender;
+
+    /// Set of capability configurations that will get published using DCF
+    std::unordered_set<std::shared_ptr<avsCommon::avs::CapabilityConfiguration>> m_capabilityConfigurations;
+
+    /// Set of observers of MessagingObserverInterface.
+    std::unordered_set<std::shared_ptr<avsCommon::sdkInterfaces::messaging::MessagingObserverInterface>> m_observers;
+
+    /// Map of messaging endpoint to state
+    std::unordered_map<std::string, MessagingEndpointState> m_messagingEndpointsState;
+
+    /// The current context for the messaging capability agent
+    std::string m_messagingContext;
+
+    /// Mutex to guard access of m_observers.
+    std::mutex m_observerMutex;
+
+    /// An executor used for serializing requests.
+    avsCommon::utils::threading::Executor m_executor;
+};
+
+/**
+ * Converts an enum to a string.
+ *
+ * @param messagingEndpoint The @c MessagingEndpoint value.
+ * @return The string form of the enum.
+ */
+inline std::string messagingEndpointToString(MessagingCapabilityAgent::MessagingEndpoint messagingEndpoint) {
+    switch (messagingEndpoint) {
+        case MessagingCapabilityAgent::MessagingEndpoint::DEFAULT:
+            return "DEFAULT";
+    }
+
+    return "UNKNOWN";
+}
+
+/**
+ * Converts an enum to a string.
+ *
+ * @param code The @c StatusErrorCode.
+ * @return The string form of the enum.
+ */
+inline std::string statusErrorCodeToString(MessagingCapabilityAgent::StatusErrorCode code) {
+    switch (code) {
+        case MessagingCapabilityAgent::StatusErrorCode::GENERIC_FAILURE:
+            return "GENERIC_FAILURE";
+        case MessagingCapabilityAgent::StatusErrorCode::NO_CONNECTIVITY:
+            return "NO_CONNECTIVITY";
+        case MessagingCapabilityAgent::StatusErrorCode::NO_PERMISSION:
+            return "NO_PERMISSION";
+    }
+
+    return "UNKNOWN";
+}
+
+/**
+ * Converts an enum to a string.
+ *
+ * @param code The @c UploadMode.
+ * @return The string form of the enum.
+ */
+inline std::string uploadModeToString(MessagingCapabilityAgent::UploadMode mode) {
+    switch (mode) {
+        case MessagingCapabilityAgent::UploadMode::DELETE_ALL_AND_STORE:
+            return "DELETE_ALL_AND_STORE";
+    }
+
+    return "UNKNOWN";
+}
+
+/**
+ * Converts an enum to a string.
+ *
+ * @param code The @c ConnectionState.
+ * @return The string form of the enum.
+ */
+inline std::string connectionStateToString(MessagingCapabilityAgent::ConnectionState connection) {
+    switch (connection) {
+        case MessagingCapabilityAgent::ConnectionState::CONNECTED:
+            return "CONNECTED";
+        case MessagingCapabilityAgent::ConnectionState::DISCONNECTED:
+            return "DISCONNECTED";
+    }
+
+    return "UNKNOWN";
+}
+
+/**
+ * Converts an enum to a string.
+ *
+ * @param code The @c PermissionState.
+ * @return The string form of the enum.
+ */
+inline std::string permissionStateToString(MessagingCapabilityAgent::PermissionState permission) {
+    switch (permission) {
+        case MessagingCapabilityAgent::PermissionState::ON:
+            return "ON";
+        case MessagingCapabilityAgent::PermissionState::OFF:
+            return "OFF";
+    }
+
+    return "UNKNOWN";
+}
+
+}  // namespace messaging
+}  // namespace capabilityAgents
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_CAPABILITYAGENTS_MESSAGING_INCLUDE_MESSAGING_MESSAGINGCAPABILITYAGENT_H_
\ No newline at end of file
diff --git a/CapabilityAgents/Messaging/src/CMakeLists.txt b/CapabilityAgents/Messaging/src/CMakeLists.txt
new file mode 100644
index 00000000..ad7b3555
--- /dev/null
+++ b/CapabilityAgents/Messaging/src/CMakeLists.txt
@@ -0,0 +1,13 @@
+add_definitions("-DACSDK_LOG_MODULE=messaging")
+
+add_library(Messaging SHARED
+        MessagingCapabilityAgent.cpp)
+
+target_include_directories(Messaging PUBLIC
+        "${Messaging_SOURCE_DIR}/include"
+        "${AVSCommon_INCLUDE_DIRS}")
+
+target_link_libraries(Messaging AVSCommon)
+
+# install target
+asdk_install()
diff --git a/CapabilityAgents/Messaging/src/MessagingCapabilityAgent.cpp b/CapabilityAgents/Messaging/src/MessagingCapabilityAgent.cpp
new file mode 100644
index 00000000..188016ba
--- /dev/null
+++ b/CapabilityAgents/Messaging/src/MessagingCapabilityAgent.cpp
@@ -0,0 +1,697 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <rapidjson/document.h>
+#include <rapidjson/error/en.h>
+#include <rapidjson/stringbuffer.h>
+#include <rapidjson/writer.h>
+
+#include <AVSCommon/AVS/CapabilityConfiguration.h>
+#include <AVSCommon/AVS/MessageRequest.h>
+#include <AVSCommon/SDKInterfaces/ContextManagerInterface.h>
+#include <AVSCommon/Utils/JSON/JSONGenerator.h>
+#include <AVSCommon/Utils/JSON/JSONUtils.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+#include "Messaging/MessagingCapabilityAgent.h"
+
+namespace alexaClientSDK {
+namespace capabilityAgents {
+namespace messaging {
+
+using namespace avsCommon::avs;
+using namespace avsCommon::sdkInterfaces;
+using namespace avsCommon::sdkInterfaces::messaging;
+using namespace avsCommon::utils::json::jsonUtils;
+using namespace avsCommon::utils::json;
+using namespace avsCommon::utils::logger;
+using namespace rapidjson;
+
+// ==== Messaging Capability Agent constants ===
+
+/// String to identify log entries originating from this file.
+static const std::string TAG{"Messaging"};
+
+/// The MessagingController interface namespace.
+static const std::string NAMESPACE{"Alexa.Comms.MessagingController"};
+
+/// MessagingController interface type.
+static const std::string MESSAGING_CAPABILITY_INTERFACE_TYPE = "AlexaInterface";
+
+/// MessagingController interface version.
+static const std::string MESSAGING_CAPABILITY_INTERFACE_VERSION = "1.0";
+
+/// The MessagingController context namespace.
+static const NamespaceAndName CONTEXT_MANAGER_MESSAGING_STATE{NAMESPACE, "MessagingControllerState"};
+
+// ==== Directives ===
+
+/// The @c SendMessage directive identifier.
+static const NamespaceAndName SEND_MESSAGE{NAMESPACE, "SendMessage"};
+
+/// The @c UpdateMessagesStatus directive identifier.
+static const NamespaceAndName UPDATE_MESSAGES_STATUS{NAMESPACE, "UpdateMessagesStatus"};
+
+/// The @c UploadConversations directive identifier.
+static const NamespaceAndName UPLOAD_CONVERSATIONS{NAMESPACE, "UploadConversations"};
+
+// ==== Events ===
+
+/// The @c SendMessageSucceeded event identifier.
+static const std::string SEND_MESSAGE_SUCCEEDED = "SendMessageSucceeded";
+
+/// The @c SendMessageFailed event identifier.
+static const std::string SEND_MESSAGE_FAILED = "SendMessageFailed";
+
+/// The @c UpdateMessagesStatusSucceeded event identifier.
+static const std::string UPDATE_MESSAGES_STATUS_SUCCEEDED = "UpdateMessagesStatusSucceeded";
+
+/// The @c UpdateMessagesStatusFailed event identifier.
+static const std::string UPDATE_MESSAGES_STATUS_FAILED = "UpdateMessagesStatusFailed";
+
+/// The @c ConversationsReport event identifier.
+static const std::string CONVERSATIONS_REPORT = "ConversationsReport";
+
+// ==== JSON constants ===
+
+/// Name for "token" JSON key.
+static constexpr char JSON_KEY_TOKEN[] = "token";
+
+/// Name for "conversationId" JSON key.
+static constexpr char JSON_KEY_CONVERSATION_ID[] = "conversationId";
+
+/// Name for "statusMap" JSON key.
+static constexpr char JSON_KEY_STATUS_MAP[] = "statusMap";
+
+/// Name for "messagingEndpoints" JSON key.
+static constexpr char JSON_KEY_MESSAGING_ENDPOINTS[] = "messagingEndpoints";
+
+/// Name for "messagingEndpointInfo" JSON key.
+static constexpr char JSON_KEY_MESSAGING_ENDPOINT_INFO[] = "messagingEndpointInfo";
+
+/// Name for "name" JSON key.
+static constexpr char JSON_KEY_MESSAGING_ENDPOINT_NAME[] = "name";
+
+/// Name for "messagingEndpointStates" JSON key.
+static constexpr char JSON_KEY_MESSAGING_ENDPOINT_STATES[] = "messagingEndpointStates";
+
+/// Name for "permissions" JSON key.
+static constexpr char JSON_KEY_MESSAGING_PERMISSIONS[] = "permissions";
+
+/// Name for "sendPermissions" JSON key.
+static constexpr char JSON_KEY_MESSAGING_SEND_PERMISSION[] = "sendPermission";
+
+/// Name for "readPermissions" JSON key.
+static constexpr char JSON_KEY_MESSAGING_READ_PERMISSION[] = "readPermission";
+
+/// Name for "connectionState" JSON key.
+static constexpr char JSON_KEY_CONNECTION_STATE[] = "connectionState";
+
+/// Name for "status" JSON value.
+static constexpr char JSON_KEY_STATUS[] = "status";
+
+/// Name for "uploadMode" JSON value.
+static constexpr char JSON_KEY_UPLOAD_MODE[] = "uploadMode";
+
+/// Name for "code" JSON key.
+static constexpr char JSON_KEY_STATUS_CODE[] = "code";
+
+/// Name for "message" JSON key.
+static constexpr char JSON_KEY_STATUS_MESSAGE[] = "message";
+
+/// Name for "conversations" JSON key.
+static constexpr char JSON_KEY_CONVERSATIONS[] = "conversations";
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+std::shared_ptr<MessagingCapabilityAgent> MessagingCapabilityAgent::create(
+    std::shared_ptr<ExceptionEncounteredSenderInterface> exceptionSender,
+    std::shared_ptr<ContextManagerInterface> contextManager,
+    std::shared_ptr<MessageSenderInterface> messageSender) {
+    if (!contextManager) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "nullContextManager"));
+        return nullptr;
+    }
+
+    if (!exceptionSender) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "nullExceptionSender"));
+        return nullptr;
+    }
+
+    if (!messageSender) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "nullMessageSender"));
+        return nullptr;
+    }
+
+    // Create instance of capability agent
+    auto messagingCapabilityAgent = std::shared_ptr<MessagingCapabilityAgent>(
+        new MessagingCapabilityAgent(exceptionSender, contextManager, messageSender));
+
+    messagingCapabilityAgent->initialize();
+
+    return messagingCapabilityAgent;
+}
+
+MessagingCapabilityAgent::MessagingCapabilityAgent(
+    std::shared_ptr<ExceptionEncounteredSenderInterface> exceptionSender,
+    std::shared_ptr<ContextManagerInterface> contextManager,
+    std::shared_ptr<MessageSenderInterface> messageSender) :
+        CapabilityAgent{NAMESPACE, exceptionSender},
+        avsCommon::utils::RequiresShutdown{"MessagingCapabilityAgent"},
+        m_contextManager{contextManager},
+        m_messageSender{messageSender} {
+}
+
+bool MessagingCapabilityAgent::initialize() {
+    ACSDK_INFO(LX(__func__));
+    // Initialize endpoint state values. One per defined messaging endpoint.
+    m_messagingEndpointsState.emplace(messagingEndpointToString(MessagingEndpoint::DEFAULT), MessagingEndpointState{});
+    // Generate the device capability configuration
+    generateCapabilityConfiguration();
+    // Register with the context manager
+    m_contextManager->addStateProvider(CONTEXT_MANAGER_MESSAGING_STATE, shared_from_this());
+    // Initialize the context
+    executeUpdateMessagingEndpointContext();
+
+    return true;
+}
+
+void MessagingCapabilityAgent::generateCapabilityConfiguration() {
+    std::unordered_map<std::string, std::string> configMap;
+
+    configMap.insert({CAPABILITY_INTERFACE_TYPE_KEY, MESSAGING_CAPABILITY_INTERFACE_TYPE});
+    configMap.insert({CAPABILITY_INTERFACE_NAME_KEY, NAMESPACE});
+    configMap.insert({CAPABILITY_INTERFACE_VERSION_KEY, MESSAGING_CAPABILITY_INTERFACE_VERSION});
+    configMap.insert({CAPABILITY_INTERFACE_CONFIGURATIONS_KEY, buildMessagingEndpointConfigurationJson()});
+
+    m_capabilityConfigurations.insert(std::make_shared<CapabilityConfiguration>(configMap));
+}
+
+std::string MessagingCapabilityAgent::buildMessagingEndpointConfigurationJson() {
+    avsCommon::utils::json::JsonGenerator jsonGenerator;
+    jsonGenerator.startArray(JSON_KEY_MESSAGING_ENDPOINTS);
+    jsonGenerator.startArrayElement();
+    jsonGenerator.startObject(JSON_KEY_MESSAGING_ENDPOINT_INFO);
+    jsonGenerator.addMember(JSON_KEY_MESSAGING_ENDPOINT_NAME, messagingEndpointToString(MessagingEndpoint::DEFAULT));
+    jsonGenerator.finishObject();
+    jsonGenerator.finishArrayElement();
+    jsonGenerator.finishArray();
+
+    ACSDK_DEBUG5(LX(__func__).sensitive("configuration", jsonGenerator.toString()));
+    return jsonGenerator.toString();
+}
+
+DirectiveHandlerConfiguration MessagingCapabilityAgent::getConfiguration() const {
+    DirectiveHandlerConfiguration configuration;
+    auto noneNonBlockingPolicy = BlockingPolicy(BlockingPolicy::MEDIUMS_NONE, false);
+
+    configuration[SEND_MESSAGE] = noneNonBlockingPolicy;
+    configuration[UPDATE_MESSAGES_STATUS] = noneNonBlockingPolicy;
+    configuration[UPLOAD_CONVERSATIONS] = noneNonBlockingPolicy;
+
+    return configuration;
+}
+
+void MessagingCapabilityAgent::provideState(
+    const CapabilityTag& stateProviderName,
+    const ContextRequestToken contextRequestToken) {
+    ACSDK_DEBUG5(
+        LX(__func__).d("contextRequestToken", contextRequestToken).sensitive("stateProviderName", stateProviderName));
+
+    m_executor.submit([this, stateProviderName, contextRequestToken] {
+        ACSDK_DEBUG5(LX("provideStateInExecutor"));
+        executeProvideState(stateProviderName, contextRequestToken);
+    });
+    return;
+}
+
+void MessagingCapabilityAgent::handleDirectiveImmediately(std::shared_ptr<AVSDirective> directive) {
+    ACSDK_DEBUG5(LX(__func__));
+    handleDirective(std::make_shared<DirectiveInfo>(directive, nullptr));
+}
+
+void MessagingCapabilityAgent::preHandleDirective(std::shared_ptr<DirectiveInfo> info) {
+    // No-op
+}
+
+/**
+ * Parses a directive payload JSON and returns a parsed document object.
+ *
+ * @param payload JSON string to parse.
+ * @param[out] document Pointer to a parsed document.
+ * @return True if parsing was successful, false otherwise.
+ */
+static bool parseDirectivePayload(const std::string& payload, Document* document) {
+    ACSDK_DEBUG5(LX(__func__));
+    if (!document) {
+        ACSDK_ERROR(LX("parseDirectivePayloadFailed").d("reason", "nullDocument"));
+        return false;
+    }
+
+    ParseResult result = document->Parse(payload);
+    if (!result) {
+        ACSDK_ERROR(LX("parseDirectivePayloadFailed")
+                        .d("reason", "parseFailed")
+                        .d("error", GetParseError_En(result.Code()))
+                        .d("offset", result.Offset()));
+        return false;
+    }
+
+    return true;
+}
+
+void MessagingCapabilityAgent::handleDirective(std::shared_ptr<DirectiveInfo> info) {
+    ACSDK_DEBUG5(LX(__func__));
+    if (!info) {
+        ACSDK_ERROR(LX("handleDirectiveFailed").d("reason", "nullDirectiveInfo"));
+        return;
+    }
+
+    m_executor.submit([this, info] {
+        const std::string directiveName = info->directive->getName();
+
+        Document payload(kObjectType);
+        if (!parseDirectivePayload(info->directive->getPayload(), &payload)) {
+            sendExceptionEncounteredAndReportFailed(
+                info, "Unable to parse payload", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+            return;
+        }
+
+        if (directiveName == SEND_MESSAGE.name) {
+            if (!executeSendMessageDirective(info, payload)) {
+                return;
+            }
+        } else if (directiveName == UPDATE_MESSAGES_STATUS.name) {
+            if (!executeUpdateMessagesStatusDirective(info, payload)) {
+                return;
+            }
+        } else if (directiveName == UPLOAD_CONVERSATIONS.name) {
+            if (!executeUploadConversationsDirective(info, payload)) {
+                return;
+            }
+        } else {
+            sendExceptionEncounteredAndReportFailed(
+                info, "Unexpected Directive", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+            return;
+        }
+
+        executeSetHandlingCompleted(info);
+    });
+}
+
+void MessagingCapabilityAgent::cancelDirective(std::shared_ptr<DirectiveInfo> info) {
+    removeDirective(info);
+}
+
+void MessagingCapabilityAgent::addObserver(std::shared_ptr<MessagingObserverInterface> observer) {
+    if (!observer) {
+        ACSDK_ERROR(LX("addObserverFailed").d("reason", "nullObserver"));
+        return;
+    }
+
+    std::lock_guard<std::mutex> lock{m_observerMutex};
+    m_observers.insert(observer);
+}
+
+void MessagingCapabilityAgent::removeObserver(std::shared_ptr<MessagingObserverInterface> observer) {
+    if (!observer) {
+        ACSDK_ERROR(LX("removeObserverFailed").d("reason", "nullObserver"));
+        return;
+    }
+
+    std::lock_guard<std::mutex> lock{m_observerMutex};
+    m_observers.erase(observer);
+}
+
+void MessagingCapabilityAgent::removeDirective(std::shared_ptr<DirectiveInfo> info) {
+    if (info->directive && info->result) {
+        CapabilityAgent::removeDirective(info->directive->getMessageId());
+    }
+}
+
+void MessagingCapabilityAgent::executeSetHandlingCompleted(std::shared_ptr<DirectiveInfo> info) {
+    ACSDK_DEBUG5(LX(__func__));
+    if (info && info->directive && info->result) {
+        info->result->setCompleted();
+    }
+    removeDirective(info);
+}
+
+bool MessagingCapabilityAgent::executeSendMessageDirective(
+    std::shared_ptr<DirectiveInfo> info,
+    rapidjson::Document& payload) {
+    rapidjson::Value::ConstMemberIterator it, it2;
+    rapidjson::Value endpointInfo;
+    std::string token, name;
+
+    // Validate token field
+    if (!findNode(payload, JSON_KEY_TOKEN, &it) || !retrieveValue(payload, JSON_KEY_TOKEN, &token) || token.empty()) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'token' is not found or empty.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    // Validate messaging endpoint { "messagingEndpointInfo" : { "name" : "DEFAULT"} }
+    if (!findNode(payload, JSON_KEY_MESSAGING_ENDPOINT_INFO, &it) || !it->value.IsObject() ||
+        !findNode(it->value, JSON_KEY_MESSAGING_ENDPOINT_NAME, &it2) ||
+        !retrieveValue(it->value, JSON_KEY_MESSAGING_ENDPOINT_NAME, &name)) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'messagingEndpointInfo' is not found.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    MessagingEndpoint endpoint;
+    // Validate against known endpoint values
+    if (name == "DEFAULT") {
+        endpoint = MessagingEndpoint::DEFAULT;
+    } else {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'name' value is invalid.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    std::unique_lock<std::mutex> lock{m_observerMutex};
+    auto observers = m_observers;
+    lock.unlock();
+
+    for (auto observer : observers) {
+        if (observer) {
+            observer->sendMessage(token, endpoint, info->directive->getPayload());
+        }
+    }
+
+    return true;
+}
+
+bool MessagingCapabilityAgent::executeUpdateMessagesStatusDirective(
+    std::shared_ptr<DirectiveInfo> info,
+    rapidjson::Document& payload) {
+    rapidjson::Value::ConstMemberIterator it, it2;
+    rapidjson::Value endpointInfo;
+    std::string token, name, conversationId;
+
+    // Validate token field
+    if (!findNode(payload, JSON_KEY_TOKEN, &it) || !retrieveValue(payload, JSON_KEY_TOKEN, &token) || token.empty()) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'token' is not found or empty.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    // Validate messaging endpoint { "messagingEndpointInfo" : { "name" : "DEFAULT"} }
+    if (!findNode(payload, JSON_KEY_MESSAGING_ENDPOINT_INFO, &it) || !it->value.IsObject() ||
+        !findNode(it->value, JSON_KEY_MESSAGING_ENDPOINT_NAME, &it2) ||
+        !retrieveValue(it->value, JSON_KEY_MESSAGING_ENDPOINT_NAME, &name)) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'messagingEndpointInfo' is not found.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    MessagingEndpoint endpoint;
+    // Validate against known endpoint values
+    if (name == "DEFAULT") {
+        endpoint = MessagingEndpoint::DEFAULT;
+    } else {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'name' value is invalid.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    // Validate conversationId field
+    if (!findNode(payload, JSON_KEY_CONVERSATION_ID, &it) ||
+        !retrieveValue(payload, JSON_KEY_CONVERSATION_ID, &conversationId) || conversationId.empty()) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'conversationId' is not found or empty.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    // Validate statusMap field
+    if (!findNode(payload, JSON_KEY_STATUS_MAP, &it) || !it->value.IsObject()) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'statusMap' is not found.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    std::unique_lock<std::mutex> lock{m_observerMutex};
+    auto observers = m_observers;
+    lock.unlock();
+
+    for (auto observer : observers) {
+        if (observer) {
+            observer->updateMessagesStatus(token, endpoint, info->directive->getPayload());
+        }
+    }
+
+    return true;
+}
+
+bool MessagingCapabilityAgent::executeUploadConversationsDirective(
+    std::shared_ptr<DirectiveInfo> info,
+    rapidjson::Document& payload) {
+    rapidjson::Value::ConstMemberIterator it, it2;
+    std::string token, name;
+
+    // Validate token field
+    if (!findNode(payload, JSON_KEY_TOKEN, &it) || !retrieveValue(payload, JSON_KEY_TOKEN, &token) || token.empty()) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'token' is not found or empty.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    // Validate messaging endpoint { "messagingEndpointInfo" : { "name" : "DEFAULT"} }
+    if (!findNode(payload, JSON_KEY_MESSAGING_ENDPOINT_INFO, &it) || !it->value.IsObject() ||
+        !findNode(it->value, JSON_KEY_MESSAGING_ENDPOINT_NAME, &it2) ||
+        !retrieveValue(it->value, JSON_KEY_MESSAGING_ENDPOINT_NAME, &name)) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'messagingEndpointInfo' is not found.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    MessagingEndpoint endpoint;
+    // Validate against known endpoint values
+    if (name == "DEFAULT") {
+        endpoint = MessagingEndpoint::DEFAULT;
+    } else {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'name' value is invalid.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    std::unique_lock<std::mutex> lock{m_observerMutex};
+    auto observers = m_observers;
+    lock.unlock();
+
+    for (auto observer : observers) {
+        if (observer) {
+            observer->uploadConversations(token, endpoint, info->directive->getPayload());
+        }
+    }
+
+    return true;
+}
+
+std::unordered_set<std::shared_ptr<CapabilityConfiguration>> MessagingCapabilityAgent::getCapabilityConfigurations() {
+    return m_capabilityConfigurations;
+}
+
+void MessagingCapabilityAgent::doShutdown() {
+    m_executor.shutdown();
+    m_messageSender.reset();
+    // Remove state provider
+    m_contextManager->removeStateProvider(CONTEXT_MANAGER_MESSAGING_STATE);
+    m_contextManager.reset();
+}
+
+void MessagingCapabilityAgent::sendMessageSucceeded(const std::string& token, MessagingEndpoint messagingEndpoint) {
+    m_executor.submit([=]() {
+        avsCommon::utils::json::JsonGenerator jsonGenerator;
+
+        // Add event data
+        jsonGenerator.startObject(JSON_KEY_MESSAGING_ENDPOINT_INFO);
+        jsonGenerator.addMember(JSON_KEY_MESSAGING_ENDPOINT_NAME, messagingEndpointToString(messagingEndpoint));
+        jsonGenerator.finishObject();
+        jsonGenerator.addMember(JSON_KEY_TOKEN, token);
+
+        // Build event
+        auto event = buildJsonEventString(SEND_MESSAGE_SUCCEEDED, "", jsonGenerator.toString());
+        auto request = std::make_shared<MessageRequest>(event.second);
+
+        // Send event
+        ACSDK_DEBUG5(LX(__func__).sensitive("event", jsonGenerator.toString()));
+        m_messageSender->sendMessage(request);
+    });
+}
+
+void MessagingCapabilityAgent::sendMessageFailed(
+    const std::string& token,
+    StatusErrorCode code,
+    const std::string& message,
+    MessagingEndpoint messagingEndpoint) {
+    m_executor.submit([=]() {
+        avsCommon::utils::json::JsonGenerator jsonGenerator;
+
+        // Add event data
+        jsonGenerator.startObject(JSON_KEY_MESSAGING_ENDPOINT_INFO);
+        jsonGenerator.addMember(JSON_KEY_MESSAGING_ENDPOINT_NAME, messagingEndpointToString(messagingEndpoint));
+        jsonGenerator.finishObject();
+        jsonGenerator.addMember(JSON_KEY_TOKEN, token);
+        jsonGenerator.startObject(JSON_KEY_STATUS);
+        jsonGenerator.addMember(JSON_KEY_STATUS_CODE, statusErrorCodeToString(code));
+        jsonGenerator.addMember(JSON_KEY_STATUS_MESSAGE, message);
+        jsonGenerator.finishObject();
+
+        // Build event
+        auto event = buildJsonEventString(SEND_MESSAGE_FAILED, "", jsonGenerator.toString());
+        auto request = std::make_shared<MessageRequest>(event.second);
+
+        // Send event
+        ACSDK_DEBUG5(LX(__func__).sensitive("event", jsonGenerator.toString()));
+        m_messageSender->sendMessage(request);
+    });
+}
+
+void MessagingCapabilityAgent::updateMessagesStatusSucceeded(
+    const std::string& token,
+    MessagingEndpoint messagingEndpoint) {
+    m_executor.submit([=]() {
+        avsCommon::utils::json::JsonGenerator jsonGenerator;
+
+        // Add event data
+        jsonGenerator.startObject(JSON_KEY_MESSAGING_ENDPOINT_INFO);
+        jsonGenerator.addMember(JSON_KEY_MESSAGING_ENDPOINT_NAME, messagingEndpointToString(messagingEndpoint));
+        jsonGenerator.finishObject();
+        jsonGenerator.addMember(JSON_KEY_TOKEN, token);
+
+        // Build event
+        auto event = buildJsonEventString(UPDATE_MESSAGES_STATUS_SUCCEEDED, "", jsonGenerator.toString());
+        auto request = std::make_shared<MessageRequest>(event.second);
+
+        // Send event
+        ACSDK_DEBUG5(LX(__func__).sensitive("event", jsonGenerator.toString()));
+        m_messageSender->sendMessage(request);
+    });
+}
+
+void MessagingCapabilityAgent::updateMessagesStatusFailed(
+    const std::string& token,
+    StatusErrorCode code,
+    const std::string& message,
+    MessagingEndpoint messagingEndpoint) {
+    m_executor.submit([=]() {
+        avsCommon::utils::json::JsonGenerator jsonGenerator;
+
+        // Add event data
+        jsonGenerator.startObject(JSON_KEY_MESSAGING_ENDPOINT_INFO);
+        jsonGenerator.addMember(JSON_KEY_MESSAGING_ENDPOINT_NAME, messagingEndpointToString(messagingEndpoint));
+        jsonGenerator.finishObject();
+        jsonGenerator.addMember(JSON_KEY_TOKEN, token);
+        jsonGenerator.startObject(JSON_KEY_STATUS);
+        jsonGenerator.addMember(JSON_KEY_STATUS_CODE, statusErrorCodeToString(code));
+        jsonGenerator.addMember(JSON_KEY_STATUS_MESSAGE, message);
+        jsonGenerator.finishObject();
+
+        // Build event
+        auto event = buildJsonEventString(UPDATE_MESSAGES_STATUS_FAILED, "", jsonGenerator.toString());
+        auto request = std::make_shared<MessageRequest>(event.second);
+
+        // Send event
+        ACSDK_DEBUG5(LX(__func__).sensitive("event", jsonGenerator.toString()));
+        m_messageSender->sendMessage(request);
+    });
+}
+
+void MessagingCapabilityAgent::conversationsReport(
+    const std::string& token,
+    const std::string& conversations,
+    UploadMode mode,
+    MessagingEndpoint messagingEndpoint) {
+    m_executor.submit([=]() {
+        avsCommon::utils::json::JsonGenerator jsonGenerator;
+
+        // Add event data
+        jsonGenerator.startObject(JSON_KEY_MESSAGING_ENDPOINT_INFO);
+        jsonGenerator.addMember(JSON_KEY_MESSAGING_ENDPOINT_NAME, messagingEndpointToString(messagingEndpoint));
+        jsonGenerator.finishObject();
+        jsonGenerator.addMember(JSON_KEY_TOKEN, token);
+        jsonGenerator.addRawJsonMember(JSON_KEY_CONVERSATIONS, conversations);
+        jsonGenerator.addMember(JSON_KEY_UPLOAD_MODE, uploadModeToString(mode));
+
+        // Build event
+        auto event = buildJsonEventString(CONVERSATIONS_REPORT, "", jsonGenerator.toString());
+        auto request = std::make_shared<MessageRequest>(event.second);
+
+        // Send event
+        ACSDK_DEBUG5(LX(__func__).sensitive("event", jsonGenerator.toString()));
+        m_messageSender->sendMessage(request);
+    });
+}
+
+void MessagingCapabilityAgent::updateMessagingEndpointState(
+    MessagingEndpointState messagingEndpointState,
+    MessagingEndpoint messagingEndpoint) {
+    m_executor.submit([=]() {
+        // Update map
+        m_messagingEndpointsState[messagingEndpointToString(messagingEndpoint)] = messagingEndpointState;
+        executeUpdateMessagingEndpointContext();
+    });
+}
+
+void MessagingCapabilityAgent::executeUpdateMessagingEndpointContext() {
+    // Update context
+    avsCommon::utils::json::JsonGenerator jsonGenerator;
+    jsonGenerator.startArray(JSON_KEY_MESSAGING_ENDPOINT_STATES);
+
+    for (auto entry : m_messagingEndpointsState) {
+        jsonGenerator.startArrayElement();
+        jsonGenerator.startObject(JSON_KEY_MESSAGING_ENDPOINT_INFO);
+        jsonGenerator.addMember(JSON_KEY_MESSAGING_ENDPOINT_NAME, entry.first);
+        jsonGenerator.finishObject();
+        jsonGenerator.addMember(JSON_KEY_CONNECTION_STATE, connectionStateToString(entry.second.connection));
+        jsonGenerator.startObject(JSON_KEY_MESSAGING_PERMISSIONS);
+        jsonGenerator.addMember(
+            JSON_KEY_MESSAGING_SEND_PERMISSION, permissionStateToString(entry.second.sendPermission));
+        jsonGenerator.addMember(
+            JSON_KEY_MESSAGING_READ_PERMISSION, permissionStateToString(entry.second.readPermission));
+        jsonGenerator.finishObject();
+        jsonGenerator.finishArrayElement();
+    }
+
+    jsonGenerator.finishArray();
+
+    // Save new context
+    m_messagingContext = jsonGenerator.toString();
+
+    ACSDK_DEBUG5(LX(__func__).sensitive("context", m_messagingContext));
+    m_contextManager->reportStateChange(
+        CONTEXT_MANAGER_MESSAGING_STATE,
+        CapabilityState{m_messagingContext},
+        AlexaStateChangeCauseType::APP_INTERACTION);
+}
+
+void MessagingCapabilityAgent::executeProvideState(
+    const CapabilityTag& stateProviderName,
+    const ContextRequestToken contextRequestToken) {
+    ACSDK_DEBUG5(LX(__func__).sensitive("context", m_messagingContext));
+    CapabilityState state{m_messagingContext};
+    m_contextManager->provideStateResponse(stateProviderName, CapabilityState{m_messagingContext}, contextRequestToken);
+}
+
+}  // namespace messaging
+}  // namespace capabilityAgents
+}  // namespace alexaClientSDK
\ No newline at end of file
diff --git a/CapabilityAgents/Messaging/test/CMakeLists.txt b/CapabilityAgents/Messaging/test/CMakeLists.txt
new file mode 100644
index 00000000..030a1271
--- /dev/null
+++ b/CapabilityAgents/Messaging/test/CMakeLists.txt
@@ -0,0 +1,8 @@
+cmake_minimum_required(VERSION 3.1 FATAL_ERROR)
+
+set(INCLUDE_PATH
+        "${Messaging_INCLUDE_DIRS}"
+        "${AVSCommon_SOURCE_DIR}/SDKInterfaces/test"
+        )
+
+discover_unit_tests("${INCLUDE_PATH}" "Messaging")
diff --git a/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp b/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp
index 5a19ef69..ad6e0984 100644
--- a/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp
+++ b/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp
@@ -39,7 +39,7 @@ static const std::string TEMPLATERUNTIME_CAPABILITY_INTERFACE_TYPE = "AlexaInter
 /// TemplateRuntime interface name
 static const std::string TEMPLATERUNTIME_CAPABILITY_INTERFACE_NAME = "TemplateRuntime";
 /// TemplateRuntime interface version
-static const std::string TEMPLATERUNTIME_CAPABILITY_INTERFACE_VERSION = "1.1";
+static const std::string TEMPLATERUNTIME_CAPABILITY_INTERFACE_VERSION = "1.2";
 
 /// String to identify log entries originating from this file.
 static const std::string TAG{"TemplateRuntime"};
diff --git a/CertifiedSender/src/CertifiedSender.cpp b/CertifiedSender/src/CertifiedSender.cpp
index 840d3147..e5f9b5d8 100644
--- a/CertifiedSender/src/CertifiedSender.cpp
+++ b/CertifiedSender/src/CertifiedSender.cpp
@@ -265,6 +265,14 @@ void CertifiedSender::mainloop() {
             // ACL to continue interacting with the old instance (for example, if it is involved in a complex flow
             // of exception / onCompleted handling), and allows us to safely try sending the new instance.
             lock.lock();
+            if (m_messagesToSend.empty()) {  // Queue might have got cleared on a separate thread.
+                lock.unlock();
+                ACSDK_DEBUG9(LX(__func__).m("retryingNotRequiredDueToLogout"));
+
+                // Resetting the fail count.
+                failedSendRetryCount = 0;
+                continue; // m_currentMessage get resets at the beining of the while loop
+            }
             m_messagesToSend.pop_front();
             m_messagesToSend.push_front(std::make_shared<CertifiedMessageRequest>(
                 m_currentMessage->getJsonContent(),
@@ -298,7 +306,9 @@ void CertifiedSender::mainloop() {
                 ACSDK_ERROR(LX("mainloop : could not erase message from storage."));
             }
 
-            m_messagesToSend.pop_front();
+            if (!m_messagesToSend.empty()) {  // Queue might have got cleared on a separate thread.
+                m_messagesToSend.pop_front();
+            }
             lock.unlock();
             // Resetting the fail count.
             failedSendRetryCount = 0;
diff --git a/ContextManager/include/ContextManager/ContextManager.h b/ContextManager/include/ContextManager/ContextManager.h
index a00d0592..12513669 100644
--- a/ContextManager/include/ContextManager/ContextManager.h
+++ b/ContextManager/include/ContextManager/ContextManager.h
@@ -269,6 +269,9 @@ private:  // Private method declarations.
      * This method returns a callback which should be invoked once the context is ready.
      * If the context is not ready, this method will return a no-op function.
      *
+     * @note The calling thread must hold @c m_requestsMutex over the call to this method. The calling thread must
+     * not be holding @c m_endpointsStateMutex.
+     *
      * @note The callback method that is returned should only be called outside of a lock to prevent deadlock scenarios.
      *
      * @note If the context is ready, the method also removes the request from the pending requests map.
diff --git a/ContextManager/src/ContextManager.cpp b/ContextManager/src/ContextManager.cpp
index 2a517aa5..e700d78c 100644
--- a/ContextManager/src/ContextManager.cpp
+++ b/ContextManager/src/ContextManager.cpp
@@ -298,9 +298,14 @@ void ContextManager::provideStateUnavailableResponse(
             }
 
             if (!isEndpointUnreachable) {
-                auto& endpointState = m_endpointsState[capabilityIdentifier.endpointId];
-                auto cachedState = endpointState.find(capabilityIdentifier);
-                if ((cachedState != endpointState.end()) && cachedState->second.capabilityState.hasValue()) {
+                bool hasCachedState = false;
+                {
+                    std::lock_guard<std::mutex> statesLock{m_endpointsStateMutex};
+                    auto& endpointState = m_endpointsState[capabilityIdentifier.endpointId];
+                    auto cachedState = endpointState.find(capabilityIdentifier);
+                    hasCachedState = (cachedState != endpointState.end()) && cachedState->second.capabilityState.hasValue();
+                }
+                if (hasCachedState) {
                     if (requestIt != m_pendingStateRequest.end()) {
                         requestIt->second.erase(capabilityIdentifier);
                     }
@@ -374,41 +379,40 @@ ContextRequestToken ContextManager::getContextInternal(
                 contextFailureCallback();
             });
         });
-
-        std::lock_guard<std::mutex> requestsLock{m_requestsMutex};
-        auto& requestEndpointId = endpointId.empty() ? m_defaultEndpointId : endpointId;
-        m_pendingRequests.emplace(token, RequestTracker(timerToken, contextRequester, bSkipReportableStateProperties));
-
         std::function<void()> contextAvailableCallback = NoopCallback;
         {
-            std::lock_guard<std::mutex> statesLock{m_endpointsStateMutex};
-
-            for (auto& capability : m_endpointsState[requestEndpointId]) {
-                auto stateInfo = capability.second;
-                auto stateProvider = capability.second.stateProvider;
-
-                if (stateProvider) {
-                    bool requestState = false;
-                    if (stateInfo.legacyCapability && stateInfo.refreshPolicy != StateRefreshPolicy::NEVER) {
-                        requestState = true;
-                    } else if (!stateInfo.legacyCapability && stateProvider->canStateBeRetrieved()) {
-                        if (stateProvider->hasReportableStateProperties()) {
-                            /// Check if the reportable state properties should be skipped.
-                            if (!bSkipReportableStateProperties) {
+            std::lock_guard<std::mutex> requestsLock{m_requestsMutex};
+            auto& requestEndpointId = endpointId.empty() ? m_defaultEndpointId : endpointId;
+            m_pendingRequests.emplace(token, RequestTracker(timerToken, contextRequester, bSkipReportableStateProperties));
+            {
+                std::lock_guard<std::mutex> statesLock{m_endpointsStateMutex};
+
+                for (auto& capability : m_endpointsState[requestEndpointId]) {
+                    auto stateInfo = capability.second;
+                    auto stateProvider = capability.second.stateProvider;
+
+                    if (stateProvider) {
+                        bool requestState = false;
+                        if (stateInfo.legacyCapability && stateInfo.refreshPolicy != StateRefreshPolicy::NEVER) {
+                            requestState = true;
+                        } else if (!stateInfo.legacyCapability && stateProvider->canStateBeRetrieved()) {
+                            if (stateProvider->hasReportableStateProperties()) {
+                                /// Check if the reportable state properties should be skipped.
+                                if (!bSkipReportableStateProperties) {
+                                    requestState = true;
+                                }
+                            } else {
                                 requestState = true;
                             }
-                        } else {
-                            requestState = true;
                         }
-                    }
 
-                    if (requestState) {
-                        stateProvider->provideState(capability.first, token);
-                        m_pendingStateRequest[token].emplace(capability.first);
+                        if (requestState) {
+                            stateProvider->provideState(capability.first, token);
+                            m_pendingStateRequest[token].emplace(capability.first);
+                        }
                     }
                 }
             }
-
             contextAvailableCallback = getContextAvailableCallbackIfReadyLocked(token, requestEndpointId);
         }
         /// Callback method should be called outside the lock.
@@ -487,6 +491,7 @@ std::function<void()> ContextManager::getContextAvailableCallbackIfReadyLocked(
 
     AVSContext context;
     auto& requestEndpointId = endpointId.empty() ? m_defaultEndpointId : endpointId;
+    std::lock_guard<std::mutex> stateProviderLock(m_endpointsStateMutex);
     for (auto& capability : m_endpointsState[requestEndpointId]) {
         auto stateProvider = capability.second.stateProvider;
         auto stateInfo = capability.second;
diff --git a/Endpoints/include/Endpoints/DefaultEndpointBuilder.h b/Endpoints/include/Endpoints/DefaultEndpointBuilder.h
index be67cc1e..f56454b4 100644
--- a/Endpoints/include/Endpoints/DefaultEndpointBuilder.h
+++ b/Endpoints/include/Endpoints/DefaultEndpointBuilder.h
@@ -101,6 +101,7 @@ public:
     DefaultEndpointBuilder& withFriendlyName(const std::string& friendlyName) override;
     DefaultEndpointBuilder& withDescription(const std::string& description) override;
     DefaultEndpointBuilder& withManufacturerName(const std::string& manufacturerName) override;
+    DefaultEndpointBuilder& withEndpointResources(const avsCommon::avs::EndpointResources& endpointResources) override;
     DefaultEndpointBuilder& withDisplayCategory(const std::vector<std::string>& displayCategories) override;
     DefaultEndpointBuilder& withAdditionalAttributes(
         const std::string& manufacturer,
diff --git a/Endpoints/include/Endpoints/EndpointAttributeValidation.h b/Endpoints/include/Endpoints/EndpointAttributeValidation.h
index 74856249..e86f41b3 100644
--- a/Endpoints/include/Endpoints/EndpointAttributeValidation.h
+++ b/Endpoints/include/Endpoints/EndpointAttributeValidation.h
@@ -34,6 +34,14 @@ namespace endpoints {
  */
 bool isEndpointIdValid(const avsCommon::sdkInterfaces::endpoints::EndpointIdentifier& identifier);
 
+/**
+ * Returns whether the given endpointResources follows AVS specification.
+ *
+ * @param endpointResources The endpointResources to be validated.
+ * @return @c true if valid; otherwise, return @c false.
+ */
+bool isEndpointResourcesValid(const avsCommon::avs::EndpointResources& endpointResources);
+
 /**
  * Returns whether the given name follows AVS specification.
  *
diff --git a/Endpoints/include/Endpoints/EndpointBuilder.h b/Endpoints/include/Endpoints/EndpointBuilder.h
index 5ae5fda2..a3a6e8ec 100644
--- a/Endpoints/include/Endpoints/EndpointBuilder.h
+++ b/Endpoints/include/Endpoints/EndpointBuilder.h
@@ -103,6 +103,8 @@ public:
     EndpointBuilder& withFriendlyName(const std::string& friendlyName) override;
     EndpointBuilder& withDescription(const std::string& description) override;
     EndpointBuilder& withManufacturerName(const std::string& manufacturerName) override;
+    EndpointBuilder& withEndpointResources(
+            const avsCommon::avs::EndpointResources& endpointResources) override;
     EndpointBuilder& withDisplayCategory(const std::vector<std::string>& displayCategories) override;
     EndpointBuilder& withAdditionalAttributes(
         const std::string& manufacturer,
@@ -208,6 +210,9 @@ private:
     /// rules apply differently.
     bool m_isDefaultEndpoint;
 
+    /// Flag used to indicate whether endpointResources is used.
+    bool m_isEndpointResourcesUsed;
+
     /// The client endpoint id that is used to build the default endpoint and generate derived endpoints.
     std::shared_ptr<avsCommon::utils::DeviceInfo> m_deviceInfo;
 
diff --git a/Endpoints/src/DefaultEndpointBuilder.cpp b/Endpoints/src/DefaultEndpointBuilder.cpp
index fce95e97..66c31d77 100644
--- a/Endpoints/src/DefaultEndpointBuilder.cpp
+++ b/Endpoints/src/DefaultEndpointBuilder.cpp
@@ -107,6 +107,12 @@ DefaultEndpointBuilder& DefaultEndpointBuilder::withManufacturerName(const std::
     return *this;
 }
 
+DefaultEndpointBuilder& DefaultEndpointBuilder::withEndpointResources(const avsCommon::avs::EndpointResources& endpointResources) {
+    ACSDK_DEBUG5(LX(__func__));
+    m_builder->withEndpointResources(endpointResources);
+    return *this;
+}
+
 DefaultEndpointBuilder& DefaultEndpointBuilder::withDisplayCategory(const std::vector<std::string>& displayCategories) {
     ACSDK_DEBUG5(LX(__func__));
     m_builder->withDisplayCategory(displayCategories);
diff --git a/Endpoints/src/EndpointAttributeValidation.cpp b/Endpoints/src/EndpointAttributeValidation.cpp
index c078d38f..5ced5929 100644
--- a/Endpoints/src/EndpointAttributeValidation.cpp
+++ b/Endpoints/src/EndpointAttributeValidation.cpp
@@ -29,6 +29,10 @@ bool isEndpointIdValid(const EndpointIdentifier& identifier) {
     return (length > 0) && (length <= AVSDiscoveryEndpointAttributes::MAX_ENDPOINT_IDENTIFIER_LENGTH);
 }
 
+bool isEndpointResourcesValid(const EndpointResources& endpointResources) {
+    return endpointResources.isValid();
+}
+
 bool isFriendlyNameValid(const std::string& name) {
     auto length = name.length();
     return (length > 0) && (length <= AVSDiscoveryEndpointAttributes::MAX_FRIENDLY_NAME_LENGTH);
diff --git a/Endpoints/src/EndpointBuilder.cpp b/Endpoints/src/EndpointBuilder.cpp
index 9d8bfc0a..b2e07d24 100644
--- a/Endpoints/src/EndpointBuilder.cpp
+++ b/Endpoints/src/EndpointBuilder.cpp
@@ -110,6 +110,7 @@ EndpointBuilder::EndpointBuilder(
         m_hasBeenBuilt{false},
         m_invalidConfiguration{false},
         m_isDefaultEndpoint{false},
+        m_isEndpointResourcesUsed{false},
         m_deviceInfo{deviceInfo},
         m_contextManager{contextManager},
         m_exceptionSender{exceptionSender},
@@ -175,6 +176,18 @@ void EndpointBuilder::finalizeAttributes() {
     m_isConfigurationFinalized = true;
 }
 
+EndpointBuilder& EndpointBuilder::withEndpointResources(
+        const avsCommon::avs::EndpointResources& endpointResources) {
+    m_isEndpointResourcesUsed = true;
+    if (!isEndpointResourcesValid(endpointResources)){
+        ACSDK_ERROR(LX(__func__).d("reason", "invalidEndpointResources"));
+        m_invalidConfiguration = true;
+        return *this;
+    }
+    m_attributes.endpointResources = endpointResources;
+    return *this;
+}
+
 EndpointBuilder& EndpointBuilder::withFriendlyName(const std::string& friendlyName) {
     if (m_isConfigurationFinalized) {
         ACSDK_ERROR(LX(std::string(__func__) + "Failed").d("reason", "operationNotAllowed"));
@@ -536,7 +549,14 @@ std::unique_ptr<EndpointInterface> EndpointBuilder::buildImplementation() {
         return nullptr;
     }
 
-    if (!m_isDefaultEndpoint && !isFriendlyNameValid(m_attributes.friendlyName)) {
+    if (!m_isDefaultEndpoint && m_isEndpointResourcesUsed
+                             && !isEndpointResourcesValid(m_attributes.endpointResources)) {
+        ACSDK_ERROR(LX("buildFailed").d("reason", "invalidEndpointResources"));
+        return nullptr;
+    }
+
+    if (!m_isDefaultEndpoint && !m_isEndpointResourcesUsed
+                             && !isFriendlyNameValid(m_attributes.friendlyName)) {
         ACSDK_ERROR(
             LX("buildFailed").d("reason", "friendlyNameInvalid").sensitive("friendlyName", m_attributes.friendlyName));
         return nullptr;
diff --git a/Metrics/UplCalculator/include/Metrics/MediaUplCalculator.h b/Metrics/UplCalculator/include/Metrics/MediaUplCalculator.h
index 62ef8973..1ca46917 100644
--- a/Metrics/UplCalculator/include/Metrics/MediaUplCalculator.h
+++ b/Metrics/UplCalculator/include/Metrics/MediaUplCalculator.h
@@ -130,7 +130,7 @@ private:
     void inhibitSubmission();
 
     /// MetricRecorder to publish UPL metrics.
-    std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> m_metricRecorder;
+    std::weak_ptr<avsCommon::utils::metrics::MetricRecorderInterface> m_metricRecorder;
 
     /// Time point for the start of the TTS when media plays after TTS
     UplTimePoint m_ttsStarted;
@@ -146,4 +146,4 @@ private:
 }  // namespace metrics
 }  // namespace alexaClientSDK
 
-#endif  // ALEXA_CLIENT_SDK_METRICS_UPLCALCULATOR_INCLUDE_METRICS_MEDIAUPLCALCULATOR_H_
\ No newline at end of file
+#endif  // ALEXA_CLIENT_SDK_METRICS_UPLCALCULATOR_INCLUDE_METRICS_MEDIAUPLCALCULATOR_H_
diff --git a/Metrics/UplCalculator/include/Metrics/TtsUplCalculator.h b/Metrics/UplCalculator/include/Metrics/TtsUplCalculator.h
index e9747b63..75a92dd3 100644
--- a/Metrics/UplCalculator/include/Metrics/TtsUplCalculator.h
+++ b/Metrics/UplCalculator/include/Metrics/TtsUplCalculator.h
@@ -91,7 +91,7 @@ private:
     void inhibitSubmission();
 
     /// MetricRecorder to publish UPL metrics.
-    std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> m_metricRecorder;
+    std::weak_ptr<avsCommon::utils::metrics::MetricRecorderInterface> m_metricRecorder;
 
     /// Stop UPL calculations for unwanted cases
     bool m_uplInhibited;
@@ -101,4 +101,4 @@ private:
 }  // namespace metrics
 }  // namespace alexaClientSDK
 
-#endif  // ALEXA_CLIENT_SDK_METRICS_UPLCALCULATOR_INCLUDE_METRICS_TTSUPLCALCULATOR_H_
\ No newline at end of file
+#endif  // ALEXA_CLIENT_SDK_METRICS_UPLCALCULATOR_INCLUDE_METRICS_TTSUPLCALCULATOR_H_
diff --git a/Metrics/UplCalculator/include/Metrics/UplMetricSink.h b/Metrics/UplCalculator/include/Metrics/UplMetricSink.h
index 0577686c..04a02d3c 100644
--- a/Metrics/UplCalculator/include/Metrics/UplMetricSink.h
+++ b/Metrics/UplCalculator/include/Metrics/UplMetricSink.h
@@ -64,11 +64,11 @@ private:
         uplCalculators;
 
     /// MetricRecorder to publish UPL metrics.
-    std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> m_metricRecorder;
+    std::weak_ptr<avsCommon::utils::metrics::MetricRecorderInterface> m_metricRecorder;
 };
 
 }  // namespace implementations
 }  // namespace metrics
 }  // namespace alexaClientSDK
 
-#endif  // ALEXA_CLIENT_SDK_METRICS_UPLCALCULATOR_INCLUDE_METRICS_UPLMETRICSINK_H_
\ No newline at end of file
+#endif  // ALEXA_CLIENT_SDK_METRICS_UPLCALCULATOR_INCLUDE_METRICS_UPLMETRICSINK_H_
diff --git a/Metrics/UplCalculator/src/MediaUplCalculator.cpp b/Metrics/UplCalculator/src/MediaUplCalculator.cpp
index e0fb7a0b..1817b390 100644
--- a/Metrics/UplCalculator/src/MediaUplCalculator.cpp
+++ b/Metrics/UplCalculator/src/MediaUplCalculator.cpp
@@ -295,8 +295,12 @@ void MediaUplCalculator::calculateMediaUpl(MediaUplType type) {
                                         .setName(DIALOG_REQUEST_ID_TAG)
                                         .setValue(m_uplData->getStringData(DIALOG_REQUEST_ID_TAG))
                                         .build());
-
-    m_metricRecorder->recordMetric(metricEventBuilder.build());
+    auto metricRecorder = m_metricRecorder.lock();
+    if (metricRecorder) {
+        metricRecorder->recordMetric(metricEventBuilder.build());
+    } else {
+        ACSDK_ERROR(LX("calculateMediaUplFailed").d("reason", "nullMetricRecorder"));
+    }
     inhibitSubmission();
 }
 
@@ -306,4 +310,4 @@ void MediaUplCalculator::inhibitSubmission() {
 
 }  // namespace implementations
 }  // namespace metrics
-}  // namespace alexaClientSDK
\ No newline at end of file
+}  // namespace alexaClientSDK
diff --git a/Metrics/UplCalculator/src/TtsUplCalculator.cpp b/Metrics/UplCalculator/src/TtsUplCalculator.cpp
index 7f12ff6b..97174c3c 100644
--- a/Metrics/UplCalculator/src/TtsUplCalculator.cpp
+++ b/Metrics/UplCalculator/src/TtsUplCalculator.cpp
@@ -174,8 +174,12 @@ void TtsUplCalculator::calculateTtsUpl() {
                                         .setName(DIALOG_REQUEST_ID_TAG)
                                         .setValue(m_uplData->getStringData(DIALOG_REQUEST_ID_TAG))
                                         .build());
-
-    m_metricRecorder->recordMetric(metricEventBuilder.build());
+    auto metricsRecorder = m_metricRecorder.lock();
+    if (metricsRecorder) {
+        metricsRecorder->recordMetric(metricEventBuilder.build());
+    } else {
+        ACSDK_ERROR(LX("calculateTtsUplFailed").d("reason", "nullMetricRecorder"));
+    }
     inhibitSubmission();
 }
 
@@ -185,4 +189,4 @@ void TtsUplCalculator::inhibitSubmission() {
 
 }  // namespace implementations
 }  // namespace metrics
-}  // namespace alexaClientSDK
\ No newline at end of file
+}  // namespace alexaClientSDK
diff --git a/Metrics/UplCalculator/src/UplMetricSink.cpp b/Metrics/UplCalculator/src/UplMetricSink.cpp
index 00e2da68..2193a609 100644
--- a/Metrics/UplCalculator/src/UplMetricSink.cpp
+++ b/Metrics/UplCalculator/src/UplMetricSink.cpp
@@ -68,13 +68,15 @@ void UplMetricSink::consumeMetric(std::shared_ptr<alexaClientSDK::avsCommon::uti
     // Reset UPL data on the start of a new utterance
     if (metricName == START_OF_UTTERANCE) {
         uplCalculators[BASE_UPL_NAME] = BaseUplCalculator::createBaseUplCalculator();
-        uplCalculators[TTS_UPL_NAME] = TtsUplCalculator::createTtsUplCalculator(m_metricRecorder);
-        uplCalculators[MEDIA_UPL_NAME] = MediaUplCalculator::createMediaUplCalculator(m_metricRecorder);
-
-        std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> uplData =
-            std::make_shared<alexaClientSDK::avsCommon::utils::metrics::UplData>();
-        for (auto& kv : uplCalculators) {
-            kv.second->setUplData(uplData);
+        auto metricRecorder = m_metricRecorder.lock();
+        if (metricRecorder) {
+            uplCalculators[TTS_UPL_NAME] = TtsUplCalculator::createTtsUplCalculator(metricRecorder);
+            uplCalculators[MEDIA_UPL_NAME] = MediaUplCalculator::createMediaUplCalculator(metricRecorder);
+            std::shared_ptr<alexaClientSDK::avsCommon::utils::metrics::UplData> uplData =
+                std::make_shared<alexaClientSDK::avsCommon::utils::metrics::UplData>();
+            for (auto& kv : uplCalculators) {
+                kv.second->setUplData(uplData);
+            }
         }
     }
 
@@ -87,4 +89,4 @@ void UplMetricSink::consumeMetric(std::shared_ptr<alexaClientSDK::avsCommon::uti
 
 }  // namespace implementations
 }  // namespace metrics
-}  // namespace alexaClientSDK
\ No newline at end of file
+}  // namespace alexaClientSDK
diff --git a/PlaylistParser/src/PlaylistUtils.cpp b/PlaylistParser/src/PlaylistUtils.cpp
index 35c437fb..0683e7c4 100644
--- a/PlaylistParser/src/PlaylistUtils.cpp
+++ b/PlaylistParser/src/PlaylistUtils.cpp
@@ -143,11 +143,9 @@ bool readFromContentFetcher(
     std::vector<char> buffer(CHUNK_SIZE, 0);
     bool streamClosed = false;
     AttachmentReader::ReadStatus previousStatus = AttachmentReader::ReadStatus::OK_TIMEDOUT;
-    ssize_t bytesReadSoFar = 0;
     size_t bytesRead = -1;
     while (!streamClosed && bytesRead != 0) {
         bytesRead = reader->read(buffer.data(), buffer.size(), &readStatus);
-        bytesReadSoFar += bytesRead;
         if (previousStatus != readStatus) {
             ACSDK_DEBUG9(LX(__func__).d("readStatus", readStatus));
             previousStatus = readStatus;
diff --git a/Settings/include/Settings/DeviceSettingsManager.h b/Settings/include/Settings/DeviceSettingsManager.h
index 5a815b81..b58b6568 100644
--- a/Settings/include/Settings/DeviceSettingsManager.h
+++ b/Settings/include/Settings/DeviceSettingsManager.h
@@ -27,6 +27,8 @@
 #include "Settings/Types/AlarmVolumeRampTypes.h"
 #include "Settings/Types/NetworkInfo.h"
 
+#include "Settings/Types/GeolocationEnablement.h"
+
 namespace alexaClientSDK {
 namespace settings {
 
@@ -66,6 +68,9 @@ using LocalesSetting = SettingInterface<DeviceLocales>;
 /// Type for network info.
 using NetworkInfoSetting = SettingInterface<types::NetworkInfo>;
 
+/// Type for geolocation.
+using GeolocationEnablementSetting = SettingInterface<types::GeolocationEnablement>;
+
 /**
  * Enumerates the settings that are kept inside DeviceSettingsManager.
  *
@@ -79,7 +84,8 @@ enum DeviceSettingsIndex {
     TIMEZONE,
     WAKE_WORDS,
     LOCALE,
-    NETWORK_INFO
+    NETWORK_INFO,
+    GEOLOCATION_ENABLEMENT
 };
 
 /// The DeviceSettingsManager will manage all common settings to alexa devices.
@@ -91,7 +97,8 @@ using DeviceSettingsManager = SettingsManager<
     TimeZoneSetting,
     WakeWordsSetting,
     LocalesSetting,
-    NetworkInfoSetting>;
+    NetworkInfoSetting,
+    GeolocationEnablementSetting>;
 
 /// An alias to shorten the name.
 using DeviceSettingManagerSettingConfigurations = std::tuple<
@@ -102,7 +109,8 @@ using DeviceSettingManagerSettingConfigurations = std::tuple<
     SettingConfiguration<TimeZoneSetting>,
     SettingConfiguration<WakeWordsSetting>,
     SettingConfiguration<LocalesSetting>,
-    SettingConfiguration<NetworkInfoSetting>>;
+    SettingConfiguration<NetworkInfoSetting>,
+    SettingConfiguration<GeolocationEnablementSetting>>;
 
 }  // namespace settings
 }  // namespace alexaClientSDK
diff --git a/Settings/include/Settings/Types/GeolocationEnablement.h b/Settings/include/Settings/Types/GeolocationEnablement.h
new file mode 100644
index 00000000..d9f45a0d
--- /dev/null
+++ b/Settings/include/Settings/Types/GeolocationEnablement.h
@@ -0,0 +1,146 @@
+/*
+    * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+    *
+    * Licensed under the Apache License, Version 2.0 (the "License").
+    * You may not use this file except in compliance with the License.
+    * A copy of the License is located at
+    *
+    *     http://aws.amazon.com/apache2.0/
+    *
+    * or in the "license" file accompanying this file. This file is distributed
+    * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+    * express or implied. See the License for the specific language governing
+    * permissions and limitations under the License.
+    */
+
+#ifndef ALEXA_CLIENT_SDK_SETTINGS_INCLUDE_SETTINGS_TYPES_GEOLOCATIONENABLEMENT_H__
+#define ALEXA_CLIENT_SDK_SETTINGS_INCLUDE_SETTINGS_TYPES_GEOLOCATIONENABLEMENT_H__
+
+#include <istream>
+#include <ostream>
+#include <string>
+
+#include <AVSCommon/Utils/JSON/JSONUtils.h>
+
+namespace alexaClientSDK {
+namespace settings {
+namespace types {
+
+/**
+ * Defines the values for Geolocation Enablement setting.
+ */
+enum class GeolocationEnablement {
+    /// Geolocation data will not be uploaded to AVS.
+    DISABLED,
+
+    /// Geolocation data will always be uploaded to AVS.
+    ENABLED
+};
+
+/**
+ * Retrieves the default value of Geolocation Enablement.
+ *
+ * @return The default value Geolocation Enablement.
+ */
+constexpr GeolocationEnablement getGeolocationEnablementDefault() {
+    return GeolocationEnablement::DISABLED;
+}
+
+/**
+ * Convert a @c GeolocationEnablement to an AVS-compliant @c std::string.
+ *
+ * @param enablement The @c GeolocationEnablement to convert.
+ * @return The AVS-compliant string representation of @c enablement.
+ */
+inline std::string enablementToString(GeolocationEnablement enablement) {
+    switch (enablement) {
+        case GeolocationEnablement::ENABLED:
+            return "ENABLED";
+        case GeolocationEnablement::DISABLED:
+            return "DISABLED";
+    }
+    return "unknown GeolocationEnablement";
+}
+
+/**
+ * Convert an AVS-compliant @c string to a @c GeolocationEnablement.
+ *
+ * @param text The string to convert.
+ * @param[out] GeolocationEnablement The converted @c GeolocationEnablement.
+ * @return @c true if the string converted succesfully, else @c false.
+ */
+inline bool stringToGeolocationEnablement(const std::string& text, GeolocationEnablement* enablement) {
+    if (nullptr == enablement) {
+        return false;
+    }
+    if (enablementToString(GeolocationEnablement::ENABLED) == text) {
+        *enablement = GeolocationEnablement::ENABLED;
+        return true;
+    } else if (enablementToString(GeolocationEnablement::DISABLED) == text) {
+        *enablement = GeolocationEnablement::DISABLED;
+        return true;
+    }
+    return false;
+}
+
+/**
+ * Write a @c GeolocationEnablement value to the given stream.
+ *
+ * @param stream The stream to write the value to.
+ * @param value The value to write to the stream as a string.
+ * @return The stream that was passed in and written to.
+ */
+inline std::ostream& operator<<(std::ostream& stream, const GeolocationEnablement& value) {
+    switch (value) {
+        case GeolocationEnablement::DISABLED:
+            stream << "DISABLED";
+            return stream;
+        case GeolocationEnablement::ENABLED:
+            stream << "ENABLED";
+            return stream;
+    }
+
+    stream.setstate(std::ios_base::failbit);
+    return stream;
+}
+
+/**
+ * Converts an input string stream value to GeolocationEnablement.
+ *
+ * @param stream The string stream to retrieve the value from.
+ * @param [out] value The value to write to.
+ * @return The stream that was passed in.
+ */
+inline std::istream& operator>>(std::istream& is, GeolocationEnablement& value) {
+    std::string str;
+    is >> str;
+    if ("DISABLED" == str) {
+        value = GeolocationEnablement::DISABLED;
+    } else if ("ENABLED" == str) {
+        value = GeolocationEnablement::ENABLED;
+    } else {
+        is.setstate(std::ios_base::failbit);
+    }
+    return is;
+}
+
+/**
+ * Convert a @c GeolocationEnablement to a @c rapidjson::Value.
+ *
+ * @param documentNode The @c rapidjson::Value to write to.
+ * @param enablement The @c GeolocationEnablement to convert.
+ * @return @c true if conversion is successful, else @c false.
+ */
+inline bool convertToValue(const rapidjson::Value& documentNode, GeolocationEnablement* enablement) {
+    std::string text;
+    if (!avsCommon::utils::json::jsonUtils::convertToValue(documentNode, &text)) {
+        return false;
+    }
+    return stringToGeolocationEnablement(text, enablement);
+}
+
+}  // namespace types
+}  // namespace settings
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_SETTINGS_INCLUDE_SETTINGS_TYPES_GEOLOCATIONENABLEMENT_H__
\ No newline at end of file
diff --git a/SpeechEncoder/OpusEncoderContext/src/CMakeLists.txt b/SpeechEncoder/OpusEncoderContext/src/CMakeLists.txt
index 00b39850..c74d7e88 100644
--- a/SpeechEncoder/OpusEncoderContext/src/CMakeLists.txt
+++ b/SpeechEncoder/OpusEncoderContext/src/CMakeLists.txt
@@ -3,10 +3,11 @@ add_definitions("-DACSDK_LOG_MODULE=opusEncoderContext")
 add_library(OpusEncoderContext SHARED
 OpusEncoderContext.cpp)
 
-find_path(OPUS_INCLUDE_DIR opus)
-find_library(OPUS_LIBRARY opus)
+find_package(Opus ${OPUS_PACKAGE_CONFIG})
+message("OPUS LIBRARY IS: ${Opus_LIBRARIES}")
+message("OPUS INCLUDE DIR IS: ${Opus_INCLUDE_DIR}")
 
-if(NOT OPUS_LIBRARY)
+if(NOT Opus_LIBRARIES)
 	message(FATAL_ERROR "Cannot find libopus")
 endif()
 
@@ -15,7 +16,7 @@ target_include_directories(OpusEncoderContext
 		"${SpeechEncoder_SOURCE_DIR}/include"
 		"${OpusEncoderContext_SOURCE_DIR}/include"
 	PRIVATE
-		${OPUS_INCLUDE_DIR}
+		${Opus_INCLUDE_DIR}
 )
 
 target_link_libraries(OpusEncoderContext
@@ -23,7 +24,7 @@ target_link_libraries(OpusEncoderContext
 		SpeechEncoder
 		AVSCommon
 	PRIVATE
-		${OPUS_LIBRARY}
+		${Opus_LIBRARIES}
 )
 
 # install target
diff --git a/capabilities/Alerts/acsdkAlerts/include/acsdkAlerts/AlertsCapabilityAgent.h b/capabilities/Alerts/acsdkAlerts/include/acsdkAlerts/AlertsCapabilityAgent.h
index 66ccd651..df60bdf9 100644
--- a/capabilities/Alerts/acsdkAlerts/include/acsdkAlerts/AlertsCapabilityAgent.h
+++ b/capabilities/Alerts/acsdkAlerts/include/acsdkAlerts/AlertsCapabilityAgent.h
@@ -347,6 +347,32 @@ private:
         acsdkAlertsInterfaces::AlertObserverInterface::State state,
         const std::string& reason);
 
+    /**
+     * A callback function to notify an object that an alert has been created with additional information about the alert.
+     *
+     * @param alertToken The AVS token of the alert.
+     * @param detailedInfo The JSON payload of detailed alert info :
+     * {
+     *      "time" : <String>
+     *      "type" : <String>
+     *      "label" : <String>
+     * }
+     * time The time string ( Scheduled Time ISO_8601 ).
+     * type The type of the alert ( ALERT, REMINDER, TIMER ).
+     * label The label of the TIMER, description for REMINDER, or empty string for ALARM.
+     */
+    void executeOnAlertCreated(
+        const std::string& alertToken,
+        const std::string& jsonPayload);
+
+    /**
+     * A handler function which will be called by our internal executor when an alert is deleted.
+     *
+     * alertToken The AVS token of the alert.
+     */
+    void executeOnAlertDeleted(
+        const std::string& alertToken);
+
     /**
      * A handler function which will be called by our internal executor to add an alert observer.
      *
@@ -375,6 +401,21 @@ private:
         acsdkAlertsInterfaces::AlertObserverInterface::State state,
         const std::string& reason = "");
 
+    /**
+     * A handler function which will be called by our internal executor to notify the observer of detailed alert info.
+     *
+     * @param alertToken The alert token. See AlertObserverInterface for more.
+     * @param jsonInfo The detailed JSON info. See AlertObserverInterface for more.
+     */
+    void executeNotifyAlertCreatedObservers(const std::string& alertToken, const std::string& jsonInfo);
+
+    /**
+     * A handler function which will be called by our internal executor to notify the observer of an alert deleted.
+     *
+     * @param alertToken The alert token. See AlertObserverInterface for more.
+     */
+    void executeNotifyAlertDeletedObservers(const std::string& alertToken);
+
     /**
      * A handler function which will be called by our internal executor to remove all alerts currently being managed.
      */
diff --git a/capabilities/Alerts/acsdkAlerts/src/AlertsCapabilityAgent.cpp b/capabilities/Alerts/acsdkAlerts/src/AlertsCapabilityAgent.cpp
index e9f8fd4f..3e615e8e 100644
--- a/capabilities/Alerts/acsdkAlerts/src/AlertsCapabilityAgent.cpp
+++ b/capabilities/Alerts/acsdkAlerts/src/AlertsCapabilityAgent.cpp
@@ -79,6 +79,9 @@ static const std::string ALERTS_CAPABILITY_INTERFACE_VERSION = "1.5";
 /// The value for Type which we need for json parsing.
 static const std::string KEY_TYPE = "type";
 
+/// The value for Label which we need for json parsing.
+static const std::string KEY_LABEL = "label";
+
 // ==== Directives ===
 
 /// The value of the SetAlert Directive.
@@ -830,6 +833,27 @@ bool AlertsCapabilityAgent::handleSetAlert(
 
     updateContextManager();
 
+    Document document( rapidjson::kObjectType );
+    document.AddMember("time", parsedAlert->getScheduledTime_ISO_8601(), document.GetAllocator());
+    document.AddMember("type", parsedAlert->getTypeName(), document.GetAllocator());
+    std::string label;
+    if (!retrieveValue(payload, KEY_LABEL, &label)) {
+        document.AddMember("label", "", document.GetAllocator());
+    } else {
+        document.AddMember("label", label, document.GetAllocator());
+    }
+    // build the json state string
+    rapidjson::StringBuffer buffer;
+    rapidjson::Writer<rapidjson::StringBuffer> writer( buffer );
+
+    if (!document.Accept( writer )) {
+        ACSDK_ERROR(LX("failedToWriteJsonDocument").m("Alert DetailedInfo not sent"));
+    } else {
+        std::string payload = buffer.GetString();
+        std::string token = parsedAlert->getToken();
+        m_executor.submit([this, token, payload]() { executeOnAlertCreated( token, payload); });
+    }
+
     return true;
 }
 
@@ -851,6 +875,9 @@ bool AlertsCapabilityAgent::handleDeleteAlert(
     submitMetric(m_metricRecorder, "failedToDeleteAlert", 0);
     updateContextManager();
 
+    std::string token = *alertToken;
+    m_executor.submit([this, token]() { executeOnAlertDeleted(token); });
+
     return true;
 }
 
@@ -880,6 +907,8 @@ bool AlertsCapabilityAgent::handleDeleteAlerts(
         if (!convertToValue(tokenArray[i], &token)) {
             ACSDK_WARN(LX("handleDeleteAlertsFailed").d("reason", "invalid token in payload"));
             continue;
+        } else {
+            m_executor.submit([this, token]() { executeOnAlertDeleted(token); });
         }
         alertTokens.push_back(token);
     }
@@ -1268,6 +1297,14 @@ void AlertsCapabilityAgent::executeOnAlertStateChange(
     });
 }
 
+void AlertsCapabilityAgent::executeOnAlertCreated(const std::string& alertToken, const std::string& payload){
+    m_executor.submit([this, alertToken, payload]() { executeNotifyAlertCreatedObservers(alertToken, payload); });
+}
+
+void AlertsCapabilityAgent::executeOnAlertDeleted(const std::string& alertToken){
+    m_executor.submit([this, alertToken]() { executeNotifyAlertDeletedObservers(alertToken); });
+}
+
 void AlertsCapabilityAgent::executeAddObserver(std::shared_ptr<AlertObserverInterface> observer) {
     ACSDK_DEBUG1(LX("executeAddObserver").d("observer", observer.get()));
     m_observers.insert(observer);
@@ -1293,6 +1330,23 @@ void AlertsCapabilityAgent::executeNotifyObservers(
     }
 }
 
+void AlertsCapabilityAgent::executeNotifyAlertCreatedObservers(
+    const std::string& alertToken,
+    const std::string& payload) {
+        ACSDK_DEBUG1(LX("executeNotifyAlertCreatedObservers").d("alertToken", alertToken).sensitive("payload", payload));
+    for (auto observer : m_observers) {
+        observer->onAlertCreated(alertToken, payload);
+    }
+}
+
+void AlertsCapabilityAgent::executeNotifyAlertDeletedObservers(
+    const std::string& alertToken) {
+        ACSDK_DEBUG1(LX("executeNotifyAlertDeletedObservers").d("alertToken", alertToken));
+    for (auto observer : m_observers) {
+        observer->onAlertDeleted(alertToken);
+    }
+}
+
 void AlertsCapabilityAgent::executeRemoveAllAlerts() {
     ACSDK_DEBUG1(LX("executeRemoveAllAlerts"));
     m_alertScheduler.clearData();
diff --git a/capabilities/Alerts/acsdkAlertsInterfaces/include/acsdkAlertsInterfaces/AlertObserverInterface.h b/capabilities/Alerts/acsdkAlertsInterfaces/include/acsdkAlertsInterfaces/AlertObserverInterface.h
index 2e47a530..bf564140 100644
--- a/capabilities/Alerts/acsdkAlertsInterfaces/include/acsdkAlertsInterfaces/AlertObserverInterface.h
+++ b/capabilities/Alerts/acsdkAlertsInterfaces/include/acsdkAlertsInterfaces/AlertObserverInterface.h
@@ -73,6 +73,29 @@ public:
         State state,
         const std::string& reason = "") = 0;
 
+    /**
+     * A callback function to notify an object that an alert has been created with additional information about the alert.
+     *
+     * @param alertToken The AVS token of the alert.
+     * @param detailedInfo The JSON payload of detailed alert info :
+     * {
+     *      "time" : <String>
+     *      "type" : <String>
+     *      "label" : <String>
+     * }
+     * time The time string ( Scheduled Time ISO_8601 ).
+     * type The type of the alert ( ALERT, REMINDER, TIMER ).
+     * label The label of the TIMER, description for REMINDER, or empty string for ALARM.
+     */
+    virtual void onAlertCreated(const std::string& alertToken, const std::string& detailedInfo) {};
+
+    /**
+     * A callback function to notify an object that an alert has been deleted.
+     *
+     * alertToken The AVS token of the alert.
+     */
+    virtual void onAlertDeleted(const std::string& alertToken) {};
+
     /**
      * Convert a @c State to a @c std::string.
      *
diff --git a/capabilities/AudioPlayer/acsdkAudioPlayer/include/acsdkAudioPlayer/AudioPlayer.h b/capabilities/AudioPlayer/acsdkAudioPlayer/include/acsdkAudioPlayer/AudioPlayer.h
index 9035acbc..88ff3f18 100644
--- a/capabilities/AudioPlayer/acsdkAudioPlayer/include/acsdkAudioPlayer/AudioPlayer.h
+++ b/capabilities/AudioPlayer/acsdkAudioPlayer/include/acsdkAudioPlayer/AudioPlayer.h
@@ -373,6 +373,9 @@ private:
         /// Cached metadata.
         std::shared_ptr<const VectorOfTags> cachedMetadata;
 
+        /// Analyzers data.
+        std::vector<avsCommon::utils::audioAnalyzer::AudioAnalyzerState> analyzersData;
+
         /**
          * Constructor.
          *
diff --git a/capabilities/AudioPlayer/acsdkAudioPlayer/src/AudioPlayer.cpp b/capabilities/AudioPlayer/acsdkAudioPlayer/src/AudioPlayer.cpp
index 45a7e5ce..fb9ad2a8 100644
--- a/capabilities/AudioPlayer/acsdkAudioPlayer/src/AudioPlayer.cpp
+++ b/capabilities/AudioPlayer/acsdkAudioPlayer/src/AudioPlayer.cpp
@@ -161,6 +161,15 @@ static const char CAPTION_TYPE_KEY[] = "type";
 /// The key under "captionData" containing the caption content
 static const char CAPTION_CONTENT_KEY[] = "content";
 
+/// The "analyzers" key used to retrieve analyzer data from directive.
+static const char KEY_ANALYZERS[] = "analyzers";
+
+/// The key used to retrieve the audio analyzer name from directive.
+static const char KEY_ANALYZERS_INTERFACE[] = "interface";
+
+/// The key used to retrieve the audio analyzer enabled state from directive.
+static const char KEY_ANALYZERS_ENABLED[] = "enabled";
+
 /// The stutter key used in @c AudioPlayer events.
 static const char STUTTER_DURATION_KEY[] = "stutterDurationInMilliseconds";
 
@@ -1257,32 +1266,29 @@ void AudioPlayer::preHandlePlayDirective(std::shared_ptr<DirectiveInfo> info) {
             audioItem.stream.token);
     }
 
-    if (!m_captionManager || !m_captionManager->isEnabled()) {
-        ACSDK_DEBUG5(LX("captionsNotParsed").d("reason", "captions disabled"));
+    rapidjson::Value::ConstMemberIterator captionIterator;
+    if (!jsonUtils::findNode(stream->value, CAPTION_KEY, &captionIterator)) {
+        captionIterator = stream->value.MemberEnd();
+        ACSDK_DEBUG3(LX("captionsNotParsed").d("reason", "keyNotFoundInPayload"));
     } else {
-        rapidjson::Value::ConstMemberIterator captionIterator;
-        if (!jsonUtils::findNode(stream->value, CAPTION_KEY, &captionIterator)) {
-            captionIterator = stream->value.MemberEnd();
-            ACSDK_DEBUG3(LX("captionsNotParsed").d("reason", "keyNotFoundInPayload"));
+        auto captionFormat = captions::CaptionFormat::UNKNOWN;
+        std::string captionFormatString;
+        if (jsonUtils::retrieveValue(captionIterator->value, CAPTION_TYPE_KEY, &captionFormatString)) {
+            captionFormat = captions::avsStringToCaptionFormat(captionFormatString);
         } else {
-            auto captionFormat = captions::CaptionFormat::UNKNOWN;
-            std::string captionFormatString;
-            if (jsonUtils::retrieveValue(captionIterator->value, CAPTION_TYPE_KEY, &captionFormatString)) {
-                captionFormat = captions::avsStringToCaptionFormat(captionFormatString);
-            } else {
-                ACSDK_WARN(LX("captionParsingIncomplete").d("reason", "failedToParseField").d("field", "type"));
-            }
-
-            std::string captionContentString;
-            if (!jsonUtils::retrieveValue(captionIterator->value, CAPTION_CONTENT_KEY, &captionContentString)) {
-                ACSDK_WARN(LX("captionParsingIncomplete").d("reason", "failedToParseField").d("field", "content"));
-            }
+            ACSDK_WARN(LX("captionParsingIncomplete").d("reason", "failedToParseField").d("field", "type"));
+        }
 
-            auto captionData = captions::CaptionData(captionFormat, captionContentString);
-            ACSDK_DEBUG5(LX("captionPayloadParsed").d("type", captionData.format));
-            audioItem.captionData = captions::CaptionData(captionFormat, captionContentString);
+        std::string captionContentString;
+        if (!jsonUtils::retrieveValue(captionIterator->value, CAPTION_CONTENT_KEY, &captionContentString)) {
+            ACSDK_WARN(LX("captionParsingIncomplete").d("reason", "failedToParseField").d("field", "content"));
         }
+
+        auto captionData = captions::CaptionData(captionFormat, captionContentString);
+        ACSDK_DEBUG5(LX("captionPayloadParsed").d("type", captionData.format));
+        audioItem.captionData = captions::CaptionData(captionFormat, captionContentString);
     }
+
     rapidjson::Value::ConstMemberIterator playRequestorJson;
     if (jsonUtils::findNode(payload, "playRequestor", &playRequestorJson)) {
         if (!jsonUtils::retrieveValue(playRequestorJson->value, "type", &playItem->playRequestor.type)) {
@@ -1301,6 +1307,29 @@ void AudioPlayer::preHandlePlayDirective(std::shared_ptr<DirectiveInfo> info) {
         }
     }
 
+    // Populate audio analyzers state from directive to play info
+    auto analyzerIterator = payload.FindMember(KEY_ANALYZERS);
+    if (payload.MemberEnd() != analyzerIterator) {
+        const rapidjson::Value& analyzersPayload = payload[KEY_ANALYZERS];
+        if (!analyzersPayload.IsArray()) {
+            ACSDK_WARN(LX("audioAnalyzerParsingIncomplete").d("reason", "NotAnArray").d("field", "analyzers"));
+        } else {
+            std::vector<avsCommon::utils::audioAnalyzer::AudioAnalyzerState> analyzersData;
+            for (auto itr = analyzersPayload.Begin(); itr != analyzersPayload.End(); ++itr) {
+                const rapidjson::Value& analyzerStatePayload = *itr;
+                auto nameIterator = analyzerStatePayload.FindMember(KEY_ANALYZERS_INTERFACE);
+                auto stateIterator = analyzerStatePayload.FindMember(KEY_ANALYZERS_ENABLED);
+                if (analyzerStatePayload.MemberEnd() != nameIterator &&
+                    analyzerStatePayload.MemberEnd() != stateIterator) {
+                    audioAnalyzer::AudioAnalyzerState state(
+                        nameIterator->value.GetString(), stateIterator->value.GetString());
+                    analyzersData.push_back(state);
+                }
+            }
+            playItem->analyzersData = analyzersData;
+        }
+    }
+
     playItem->audioItem = audioItem;
     m_executor.submit([this, info, playItem] {
         if (isMessageInQueue(playItem->messageId)) {
@@ -2367,6 +2396,18 @@ bool AudioPlayer::configureMediaPlayer(std::shared_ptr<PlayDirectiveInfo>& playb
             SourceConfig cfg = emptySourceConfig();
             cfg.endOffset = playbackItem->audioItem.stream.endOffset;
             cfg.audioNormalizationConfig.enabled = playbackItem->normalizationEnabled;
+
+            auto& mediaDescription = cfg.mediaDescription;
+            mediaDescription.mediaSessionId = "";
+            mediaDescription.mixingBehavior = playbackItem->mixingBehavior;
+            mediaDescription.focusChannel = "Content";
+            mediaDescription.trackId = playbackItem->audioItem.id;
+            mediaDescription.caption.set(playbackItem->audioItem.captionData);
+            mediaDescription.analyzers.set(playbackItem->analyzersData);
+            auto playBehavior = playBehaviorToString(playbackItem->playBehavior);
+            mediaDescription.additionalData.insert(std::pair<std::string, std::string>("PlayBehavior", playBehavior));
+            mediaDescription.enabled = true;
+
             sourceId = mediaPlayer->setSource(
                 playbackItem->audioItem.stream.url,
                 playbackItem->audioItem.stream.offset,
diff --git a/capabilities/DeviceSetup/acsdkDeviceSetup/include/acsdkDeviceSetup/DeviceSetupFactory.h b/capabilities/DeviceSetup/acsdkDeviceSetup/include/acsdkDeviceSetup/DeviceSetupFactory.h
new file mode 100644
index 00000000..eebe0078
--- /dev/null
+++ b/capabilities/DeviceSetup/acsdkDeviceSetup/include/acsdkDeviceSetup/DeviceSetupFactory.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ACSDKDEVICESETUP_DEVICESETUPFACTORY_H_
+#define ACSDKDEVICESETUP_DEVICESETUPFACTORY_H_
+
+#include <memory>
+
+#include <acsdkDeviceSetupInterfaces/DeviceSetupInterface.h>
+
+#include <AVSCommon/SDKInterfaces/CapabilityConfigurationInterface.h>
+#include <AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h>
+#include <AVSCommon/SDKInterfaces/MessageSenderInterface.h>
+#include <AVSCommon/Utils/Optional.h>
+
+namespace alexaClientSDK {
+namespace acsdkDeviceSetup {
+
+/// This structure contains the interfaces to interact with the InputController Capability Agent.
+struct DeviceSetupFactoryInterfaces {
+    /// Instance of DeviceSetup.
+    std::shared_ptr<acsdkDeviceSetupInterfaces::DeviceSetupInterface> deviceSetup;
+};
+
+/**
+ * Creates a new DeviceSetup instance.
+ *
+ * @param messageSender Used for sending events.
+ * @return An @c Optional @c DeviceSetupFactoryInterfaces object.
+ */
+avsCommon::utils::Optional<DeviceSetupFactoryInterfaces> createDeviceSetup(
+    const std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface>& messageSender);
+
+}  // namespace acsdkInteractionModel
+}  // namespace alexaClientSDK
+
+#endif  // ACSDKDEVICESETUP_DEVICESETUPFACTORY_H_
diff --git a/capabilities/DeviceSetup/acsdkDeviceSetup/src/CMakeLists.txt b/capabilities/DeviceSetup/acsdkDeviceSetup/src/CMakeLists.txt
index e5524c35..c495f5e1 100644
--- a/capabilities/DeviceSetup/acsdkDeviceSetup/src/CMakeLists.txt
+++ b/capabilities/DeviceSetup/acsdkDeviceSetup/src/CMakeLists.txt
@@ -3,6 +3,7 @@ add_definitions("-DACSDK_LOG_MODULE=acsdkDeviceSetup")
 add_library(
     acsdkDeviceSetup SHARED
     DeviceSetup.cpp
+    DeviceSetupFactory.cpp
     DeviceSetupMessageRequest.cpp
     DeviceSetupComponent.cpp
 )
diff --git a/capabilities/DeviceSetup/acsdkDeviceSetup/src/DeviceSetupFactory.cpp b/capabilities/DeviceSetup/acsdkDeviceSetup/src/DeviceSetupFactory.cpp
new file mode 100644
index 00000000..4516a871
--- /dev/null
+++ b/capabilities/DeviceSetup/acsdkDeviceSetup/src/DeviceSetupFactory.cpp
@@ -0,0 +1,38 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include "acsdkDeviceSetup/DeviceSetup.h"
+#include "acsdkDeviceSetup/DeviceSetupFactory.h"
+
+namespace alexaClientSDK {
+namespace acsdkDeviceSetup {
+
+using namespace avsCommon::utils;
+
+Optional<DeviceSetupFactoryInterfaces> createDeviceSetup(
+    const std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface>& messageSender) {
+    auto deviceSetup = DeviceSetup::createDeviceSetupInterface(messageSender);
+    if (!deviceSetup) {
+        return Optional<DeviceSetupFactoryInterfaces>();
+    }
+
+    DeviceSetupFactoryInterfaces interfaces;
+    interfaces.deviceSetup = deviceSetup;
+
+    return Optional<DeviceSetupFactoryInterfaces>(interfaces);
+}
+
+}  // namespace acsdkDeviceSetup
+}  // namespace alexaClientSDK
\ No newline at end of file
diff --git a/capabilities/DoNotDisturb/acsdkDoNotDisturb/src/DNDSettingProtocol.cpp b/capabilities/DoNotDisturb/acsdkDoNotDisturb/src/DNDSettingProtocol.cpp
index 82222807..035ea063 100644
--- a/capabilities/DoNotDisturb/acsdkDoNotDisturb/src/DNDSettingProtocol.cpp
+++ b/capabilities/DoNotDisturb/acsdkDoNotDisturb/src/DNDSettingProtocol.cpp
@@ -179,15 +179,11 @@ bool DNDSettingProtocol::avsChange(
         return false;
     }
 
-    std::promise<bool> requestSaved;
-    auto future = requestSaved.get_future();
-    m_executor.submit([this, applyChange, revertChange, notifyObservers, &requestSaved]() {
+    m_executor.submit([this, applyChange, revertChange, notifyObservers]() {
         // Log request before setting the value for recovery.
         if (!m_storage->updateSettingStatus(m_key, SettingStatus::AVS_CHANGE_IN_PROGRESS)) {
-            requestSaved.set_value(false);
             return;
         }
-        requestSaved.set_value(true);
 
         notifyObservers(SettingNotifications::AVS_CHANGE_IN_PROGRESS);
 
@@ -217,7 +213,7 @@ bool DNDSettingProtocol::avsChange(
             ACSDK_ERROR(LX("avsChangeFailed").d("reason", "cannotUpdateStatus"));
         }
     });
-    return future.get();
+    return true;
 }
 
 bool DNDSettingProtocol::restoreValue(ApplyDbChangeFunction applyChange, SettingNotificationFunction notifyObservers) {
diff --git a/capabilities/Notifications/acsdkNotifications/include/acsdkNotifications/NotificationsCapabilityAgent.h b/capabilities/Notifications/acsdkNotifications/include/acsdkNotifications/NotificationsCapabilityAgent.h
index ed94f6d7..cb9a4101 100644
--- a/capabilities/Notifications/acsdkNotifications/include/acsdkNotifications/NotificationsCapabilityAgent.h
+++ b/capabilities/Notifications/acsdkNotifications/include/acsdkNotifications/NotificationsCapabilityAgent.h
@@ -93,6 +93,29 @@ public:
             avsCommon::sdkInterfaces::endpoints::EndpointCapabilitiesRegistrarInterface> endpointCapabilitiesRegistrar,
         const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder);
 
+    /**
+     * Creates a new @c NotificationsCapabilityAgent instance.
+     *
+     * @param notificationsStorage The storage interface to the NotificationIndicator database.
+     * @param renderer The instance of the @c NotificationRendererInterface used to play assets associated with
+     * notifications.
+     * @param contextManager The AVS Context manager used to generate system context for events.
+     * @param exceptionSender The object to use for sending AVS Exception messages.
+     * @param notificationsAudioFactory The audio factory object to produce the default notification sound.
+     * @param observers The set of observers that will be notified of IndicatorState changes.
+     * @param dataManager A dataManager object that will track the CustomerDataHandler.
+     * @param metricRecorder The metric recorder.
+     * @return A @c std::shared_ptr to the new @c NotificationsCapabilityAgent instance.
+     */
+    static std::shared_ptr<NotificationsCapabilityAgent> create(
+        std::shared_ptr<acsdkNotificationsInterfaces::NotificationsStorageInterface> notificationsStorage,
+        std::shared_ptr<acsdkNotificationsInterfaces::NotificationRendererInterface> renderer,
+        std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
+        std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
+        std::shared_ptr<avsCommon::sdkInterfaces::audio::NotificationsAudioFactoryInterface> notificationsAudioFactory,
+        std::shared_ptr<registrationManager::CustomerDataManagerInterface> dataManager,
+        std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> metricRecorder = nullptr);
+
     /**
      * Gets the @c NotificationsNotifierInterface that can relay notification changes to observers.
      *
diff --git a/capabilities/Notifications/acsdkNotifications/src/NotificationsCapabilityAgent.cpp b/capabilities/Notifications/acsdkNotifications/src/NotificationsCapabilityAgent.cpp
index 547a64e9..598e1e01 100644
--- a/capabilities/Notifications/acsdkNotifications/src/NotificationsCapabilityAgent.cpp
+++ b/capabilities/Notifications/acsdkNotifications/src/NotificationsCapabilityAgent.cpp
@@ -163,6 +163,55 @@ std::shared_ptr<NotificationsCapabilityAgent> NotificationsCapabilityAgent::crea
     return notificationsCapabilityAgent;
 }
 
+std::shared_ptr<NotificationsCapabilityAgent> NotificationsCapabilityAgent::create(
+    std::shared_ptr<acsdkNotificationsInterfaces::NotificationsStorageInterface> notificationsStorage,
+    std::shared_ptr<acsdkNotificationsInterfaces::NotificationRendererInterface> renderer,
+    std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
+    std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
+    std::shared_ptr<avsCommon::sdkInterfaces::audio::NotificationsAudioFactoryInterface> notificationsAudioFactory,
+    std::shared_ptr<registrationManager::CustomerDataManagerInterface> dataManager,
+    std::shared_ptr<MetricRecorderInterface> metricRecorder) {
+    if (nullptr == notificationsStorage) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "nullNotificationsStorage"));
+        return nullptr;
+    }
+    if (nullptr == renderer) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "nullRenderer"));
+        return nullptr;
+    }
+    if (nullptr == contextManager) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "nullContextManager"));
+        return nullptr;
+    }
+    if (nullptr == exceptionSender) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "nullExceptionSender"));
+        return nullptr;
+    }
+    if (nullptr == notificationsAudioFactory) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "nullNotificationsAudioFactory"));
+        return nullptr;
+    }
+    if (nullptr == dataManager) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "nullDataManager"));
+        return nullptr;
+    }
+
+    auto notificationsCapabilityAgent = std::shared_ptr<NotificationsCapabilityAgent>(new NotificationsCapabilityAgent(
+        notificationsStorage,
+        renderer,
+        contextManager,
+        exceptionSender,
+        notificationsAudioFactory,
+        dataManager,
+        metricRecorder));
+
+    if (!notificationsCapabilityAgent->init()) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "initFailed"));
+        return nullptr;
+    }
+    return notificationsCapabilityAgent;
+}
+
 NotificationsCapabilityAgent::NotificationsCapabilityAgent(
     std::shared_ptr<acsdkNotificationsInterfaces::NotificationsStorageInterface> notificationsStorage,
     std::shared_ptr<acsdkNotificationsInterfaces::NotificationRendererInterface> renderer,
diff --git a/cmakeBuild/BuildDefaults.cmake b/cmakeBuild/BuildDefaults.cmake
index 4e4375a7..186a8a59 100644
--- a/cmakeBuild/BuildDefaults.cmake
+++ b/cmakeBuild/BuildDefaults.cmake
@@ -22,6 +22,11 @@ macro(include_once module)
     endif()
 endmacro()
 
+if(ACSDK_ENABLE_CURL_HTTP_VERSION_2_PRIOR_KNOWLEDGE)
+    message(STATUS "Enabling curl http version 2 prior knowledge")
+    add_definitions(-DACSDK_ENABLE_CURL_HTTP_VERSION_2_PRIOR_KNOWLEDGE)
+endif()
+
 # Disallow out-of-source-builds.
 include_once(DisallowOutOfSourceBuilds)
 
diff --git a/cmakeBuild/cmake/BuildOptions.cmake b/cmakeBuild/cmake/BuildOptions.cmake
index 28faebe1..070b5a02 100644
--- a/cmakeBuild/cmake/BuildOptions.cmake
+++ b/cmakeBuild/cmake/BuildOptions.cmake
@@ -12,7 +12,7 @@ if(NOT CMAKE_BUILD_TYPE)
 endif()
 
 # Verify the build type is valid.
-set(buildTypes DEBUG RELEASE MINSIZEREL)
+set(buildTypes DEBUG RELEASE MINSIZEREL RELWITHDEBINFO)
 
 string(TOUPPER "${CMAKE_BUILD_TYPE}" buildType)
 
@@ -27,8 +27,8 @@ if (buildTypeFound EQUAL -1)
     message("###############################################################################")
     message("#                                                                             #")
     message("# ERROR:                                                                      #")
-    message("# Unknown build type selected. Please select from DEBUG, RELEASE, or          #")
-    message("# MINSIZEREL.                                                                 #")
+    message("# Unknown build type selected. Please select from DEBUG, RELEASE, MINSIZEREL, #")
+    message("# or RELWITHDEBINFO.                                                          #")
     message("#                                                                             #")
     message("# Build Type:                                                                 #")
     message("#     ${buildType}${buildTypePad}#")
@@ -56,26 +56,36 @@ if (NOT MSVC)
     set(CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG      "-DDEBUG -DACSDK_LOG_ENABLED -DACSDK_DEBUG_LOG_ENABLED -Wall -Werror -Wsign-compare -g")
     set(CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE    "-DNDEBUG -Wall -Werror -O2")
     set(CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL "-DNDEBUG -Wall -Werror -Os")
+    set(CXX_PLATFORM_DEPENDENT_FLAGS_RELWITHDEBINFO "-DNDEBUG -Wall -Werror -O2 -g")
     if (CMAKE_COMPILER_IS_GNUCXX AND (NOT (CMAKE_CXX_COMPILER_VERSION VERSION_LESS "8.0")))
         set(CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG "${CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG} -Wno-error=class-memaccess")
         set(CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE "${CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE} -Wno-error=class-memaccess")
         set(CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL "${CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL} -Wno-error=class-memaccess")
+        set(CXX_PLATFORM_DEPENDENT_FLAGS_RELWITHDEBINFO "${CXX_PLATFORM_DEPENDENT_FLAGS_RELWITHDEBINFO} -Wno-error=class-memaccess")
     endif()
     if (CMAKE_COMPILER_IS_GNUCXX AND (NOT (CMAKE_CXX_COMPILER_VERSION VERSION_LESS "9.0")))
         set(CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG "${CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG} -Wno-error=deprecated-copy")
         set(CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE "${CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE} -Wno-error=deprecated-copy")
         set(CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL "${CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL} -Wno-error=deprecated-copy")
+        set(CXX_PLATFORM_DEPENDENT_FLAGS_RELWITHDEBINFO "${CXX_PLATFORM_DEPENDENT_FLAGS_RELWITHDEBINFO} -Wno-error=deprecated-copy")
     endif()
     if (MINGW)
         # Debug build on MinGW needs O1 optimzation to reduce the code size. This is to get around GCC's string table overflow issue on MinGW.
         set(CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG "${CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG} -O1 -fuse-ld=lld")
         set(CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE "${CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE} -fuse-ld=lld")
         set(CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL "${CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL} -fuse-ld=lld")
+        set(CXX_PLATFORM_DEPENDENT_FLAGS_RELWITHDEBINFO "${CXX_PLATFORM_DEPENDENT_FLAGS_RELWITHDEBINFO} -fuse-ld=lld")
     endif()
+    # Security flags
+    set(CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG "${CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG} -fstack-protector-strong -Wformat -Wformat-security -Werror=format-security")
+    set(CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE "${CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE} -fstack-protector-strong -Wformat -Wformat-security -Werror=format-security -D_FORTIFY_SOURCE=2")
+    set(CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL "${CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL} -fstack-protector-strong -Wformat -Wformat-security -Werror=format-security -D_FORTIFY_SOURCE=2")
+    set(CXX_PLATFORM_DEPENDENT_FLAGS_RELWITHDEBINFO "${CXX_PLATFORM_DEPENDENT_FLAGS_RELWITHDEBINFO} -fstack-protector-strong -Wformat -Wformat-security -Werror=format-security -D_FORTIFY_SOURCE=2")
 else()
     set(CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG      "/DDEBUG /D_SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING -DACSDK_LOG_ENABLED -DACSDK_DEBUG_LOG_ENABLED /W4 /Zi /VZ /ZW /Od /MDd")
     set(CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE    "/DNDEBUG /D_SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING /W4 /O2 /VZ /ZW /MD")
     set(CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL "/DNDEBUG /D_SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING /W4 /O1 /VZ /ZW /MD")
+    set(CXX_PLATFORM_DEPENDENT_FLAGS_RELWITHDEBINFO    "/DNDEBUG /D_SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING /W4 /O2 /VZ /ZW /MD /Zi")
     add_definitions("-DNOMINMAX")
     add_definitions("-D_CRT_SECURE_NO_WARNINGS")
     set(CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS ON)
@@ -85,10 +95,12 @@ if (CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
     set(CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG "${CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG} -Wconditional-uninitialized -Wsometimes-uninitialized -Wuninitialized")
     set(CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE "${CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE} -Wconditional-uninitialized -Wsometimes-uninitialized -Wuninitialized")
     set(CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL "${CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL} -Wconditional-uninitialized -Wsometimes-uninitialized -Wuninitialized")
+    set(CXX_PLATFORM_DEPENDENT_FLAGS_RELWITHDEBINFO "${CXX_PLATFORM_DEPENDENT_FLAGS_RELWITHDEBINFO} -Wconditional-uninitialized -Wsometimes-uninitialized -Wuninitialized")
     if (MINGW)
         set(CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG "${CXX_PLATFORM_DEPENDENT_FLAGS_DEBUG} -Wno-error=sentinel")
         set(CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE "${CXX_PLATFORM_DEPENDENT_FLAGS_RELEASE} -Wno-error=sentinel")
         set(CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL "${CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL} -Wno-error=sentinel")
+        set(CXX_PLATFORM_DEPENDENT_FLAGS_RELWITHDEBINFO "${CXX_PLATFORM_DEPENDENT_FLAGS_RELWITHDEBINFO} -Wno-error=sentinel")
     endif()
 endif()
 # Debug build, default.
@@ -102,3 +114,15 @@ set(CMAKE_C_FLAGS_RELEASE ${CMAKE_CXX_FLAGS_RELEASE} CACHE INTERNAL "Flags used
 # Minimum sized release build.
 set(CMAKE_CXX_FLAGS_MINSIZEREL "${CXX_PLATFORM_DEPENDENT_FLAGS_MINSIZEREL} -DRAPIDJSON_HAS_STDSTRING" CACHE INTERNAL "Flags used for minimum sized RELEASE builds" FORCE)
 set(CMAKE_C_FLAGS_MINSIZEREL ${CMAKE_CXX_FLAGS_RELEASE} CACHE INTERNAL "Flags used for minimum sized RELEASE builds" FORCE)
+
+# Release build with debug info.
+set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CXX_PLATFORM_DEPENDENT_FLAGS_RELWITHDEBINFO} -DRAPIDJSON_HAS_STDSTRING" CACHE INTERNAL "Flags used for RELWITHDEBINFO builds" FORCE)
+set(CMAKE_C_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELWITHDEBINFO} -g" CACHE INTERNAL "Flags used for RELWITHDEBINFO builds" FORCE)
+
+# Linker flags
+if(CMAKE_SYSTEM_NAME MATCHES "^(Linux|Android|QNX)$")
+    set(CMAKE_SHARED_LINKER_FLAGS_DEBUG "-Wl,-z,relro,-z,now -Wl,-z,noexecstack")
+    set(CMAKE_SHARED_LINKER_FLAGS_RELEASE "-Wl,-z,relro,-z,now -Wl,-z,noexecstack")
+    set(CMAKE_SHARED_LINKER_FLAGS_MINSIZEREL "-Wl,-z,relro,-z,now -Wl,-z,noexecstack")
+    set(CMAKE_SHARED_LINKER_FLAGS_RELWITHDEBINFO "-Wl,-z,relro,-z,now -Wl,-z,noexecstack")
+endif()
diff --git a/cmakeBuild/cmake/Crypto.cmake b/cmakeBuild/cmake/Crypto.cmake
index 5f995d66..81e0c7a2 100644
--- a/cmakeBuild/cmake/Crypto.cmake
+++ b/cmakeBuild/cmake/Crypto.cmake
@@ -13,8 +13,11 @@ set(CRYPTO_INCLUDE_DIR "" CACHE PATH "Crypto include directory.")
 mark_as_advanced(CRYPTO_INCLUDE_DIR CRYPTO_LIBRARY)
 
 if (("${CRYPTO_LIBRARY}" STREQUAL "") OR ("${CRYPTO_INCLUDE_DIR}" STREQUAL ""))
-    find_package(PkgConfig)
-    pkg_check_modules(CRYPTO REQUIRED libcrypto)
+    find_package(OpenSSL ${OPENSSL_PACKAGE_CONFIG})
+    set(CRYPTO_LDFLAGS ${OpenSSL_LIBS})
+    set(CRYPTO_INCLUDE_DIRS ${OpenSSL_SSL_INCLUDE_DIR})
+    message("CRYPTO LIBRARY IS: ${CRYPTO_LDFLAGS}")
+    message("CRYPTO INCLUDE DIR IS: ${CRYPTO_INCLUDE_DIRS}")
 else()
     set(CRYPTO_LDFLAGS ${CRYPTO_LIBRARY})
     set(CRYPTO_INCLUDE_DIRS ${CRYPTO_INCLUDE_DIR})
diff --git a/cmakeBuild/cmake/Sqlite.cmake b/cmakeBuild/cmake/Sqlite.cmake
index 6c78dd29..a33df62c 100644
--- a/cmakeBuild/cmake/Sqlite.cmake
+++ b/cmakeBuild/cmake/Sqlite.cmake
@@ -13,8 +13,11 @@ set(SQLITE_INCLUDE_DIR "" CACHE PATH "SQLITE include directory.")
 mark_as_advanced(SQLITE_INCLUDE_DIR SQLITE_LIBRARY)
 
 if (("${SQLITE_LIBRARY}" STREQUAL "") OR ("${SQLITE_INCLUDE_DIR}" STREQUAL ""))
-    find_package(PkgConfig)
-    pkg_check_modules(SQLITE REQUIRED sqlite3)
+    find_package(SQLite3 ${SQLITE3_PACKAGE_CONFIG})
+    set(SQLITE_LDFLAGS ${SQLite_LIBRARIES})
+    set(SQLITE_INCLUDE_DIRS ${SQLite_INCLUDE_DIR})
+    message("SQLITE LIBRARY IS: ${SQLITE_LDFLAGS}")
+    message("SQLITE INCLUDE DIR IS: ${SQLITE_INCLUDE_DIRS}")
 else()
     set(SQLITE_LDFLAGS ${SQLITE_LIBRARY})
     set(SQLITE_INCLUDE_DIRS ${SQLITE_INCLUDE_DIR})
diff --git a/core/acsdkRegistrationManager/include/RegistrationManager/RegistrationManagerFactory.h b/core/acsdkRegistrationManager/include/RegistrationManager/RegistrationManagerFactory.h
new file mode 100644
index 00000000..4e858fd0
--- /dev/null
+++ b/core/acsdkRegistrationManager/include/RegistrationManager/RegistrationManagerFactory.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef REGISTRATIONMANAGER_REGISTRATIONMANAGERFACTORY_H_
+#define REGISTRATIONMANAGER_REGISTRATIONMANAGERFACTORY_H_
+
+#include <memory>
+
+#include <AVSCommon/SDKInterfaces/AVSConnectionManagerInterface.h>
+#include <AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h>
+#include <AVSCommon/Utils/Metrics/MetricRecorderInterface.h>
+#include <AVSCommon/Utils/Optional.h>
+#include <RegistrationManager/CustomerDataManagerInterface.h>
+#include <RegistrationManager/RegistrationManagerInterface.h>
+#include <RegistrationManager/RegistrationNotifierInterface.h>
+
+namespace alexaClientSDK {
+namespace registrationManager {
+
+/// This structure contains the interfaces to interact with the RegistrationManager.
+struct RegistrationManagerFactoryInterfaces {
+    /// Registration Manager instance
+    std::shared_ptr<registrationManager::RegistrationManagerInterface> registrationManager;
+
+    /// Interface for Notifier.
+    std::shared_ptr<registrationManager::RegistrationNotifierInterface> notifier;
+};
+
+/**
+ * Creates a new instance of @c RegistrationManagerFactoryInterfaces.
+ *
+ * @note This method is @deprecated. Consider using RegistrationManagerComponent to create an instance of
+ * @c RegistrationManagerInterface.
+ * @return A pointer to the @c RegistrationManagerInterface.
+ */
+avsCommon::utils::Optional<RegistrationManagerFactoryInterfaces> createRegistrationManagerInterfaces(
+    const std::shared_ptr<registrationManager::CustomerDataManagerInterface>& customerDataManager,
+    const std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface>& connectionManager,
+    const std::shared_ptr<avsCommon::sdkInterfaces::DirectiveSequencerInterface>& directiveSequencer,
+    const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder);
+
+}  // namespace registrationManager
+}  // namespace alexaClientSDK
+
+#endif  // REGISTRATIONMANAGER_REGISTRATIONMANAGERFACTORY_H_
diff --git a/core/acsdkRegistrationManager/src/CMakeLists.txt b/core/acsdkRegistrationManager/src/CMakeLists.txt
index b9903afe..9eb0a6d4 100644
--- a/core/acsdkRegistrationManager/src/CMakeLists.txt
+++ b/core/acsdkRegistrationManager/src/CMakeLists.txt
@@ -4,6 +4,7 @@ add_library(RegistrationManager SHARED
         CustomerDataHandler.cpp
         CustomerDataManager.cpp
         CustomerDataManagerFactory.cpp
+        RegistrationManagerFactory.cpp
         RegistrationManager.cpp
         RegistrationManagerComponent.cpp
         RegistrationNotifier.cpp)
diff --git a/core/acsdkRegistrationManager/src/RegistrationManagerFactory.cpp b/core/acsdkRegistrationManager/src/RegistrationManagerFactory.cpp
new file mode 100644
index 00000000..8544b878
--- /dev/null
+++ b/core/acsdkRegistrationManager/src/RegistrationManagerFactory.cpp
@@ -0,0 +1,51 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <RegistrationManager/CustomerDataManager.h>
+#include <RegistrationManager/RegistrationManager.h>
+#include <RegistrationManager/RegistrationNotifier.h>
+
+#include "RegistrationManager/RegistrationManagerFactory.h"
+
+namespace alexaClientSDK {
+namespace registrationManager {
+
+using namespace avsCommon::utils;
+
+Optional<RegistrationManagerFactoryInterfaces> createRegistrationManagerInterfaces(
+    const std::shared_ptr<registrationManager::CustomerDataManagerInterface>& customerDataManager,
+    const std::shared_ptr<avsCommon::sdkInterfaces::AVSConnectionManagerInterface>& connectionManager,
+    const std::shared_ptr<avsCommon::sdkInterfaces::DirectiveSequencerInterface>& directiveSequencer,
+    const std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>& metricRecorder) {
+    auto notifier = RegistrationNotifier::createRegistrationNotifierInterface();
+    if (!notifier) {
+        return Optional<RegistrationManagerFactoryInterfaces>();
+    }
+
+    auto registrationManager = RegistrationManager::createRegistrationManagerInterface(
+        customerDataManager, notifier, connectionManager, directiveSequencer, metricRecorder);
+    if (!registrationManager) {
+        return Optional<RegistrationManagerFactoryInterfaces>();
+    }
+
+    RegistrationManagerFactoryInterfaces interfaces;
+    interfaces.registrationManager = registrationManager;
+    interfaces.notifier = notifier;
+
+    return Optional<RegistrationManagerFactoryInterfaces>(interfaces);
+}
+
+}  // namespace registrationManager
+}  // namespace alexaClientSDK
-- 
2.36.0

